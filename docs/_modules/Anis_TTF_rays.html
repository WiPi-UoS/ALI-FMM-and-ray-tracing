<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anis_TTF_rays &mdash; Anisotropic Traveltime Fields and Ray Tracing 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../Main.html" class="icon icon-home"> Anisotropic Traveltime Fields and Ray Tracing
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Anis_TTF_class.html">ALI-FMM and Ray Tracing Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Anis_TTF_functions.html">Module Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../JupyterNotebook.html">Jupyter Notebook</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../Main.html">Anisotropic Traveltime Fields and Ray Tracing</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../Main.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Module code</a> &raquo;</li>
      <li>Anis_TTF_rays</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for Anis_TTF_rays</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Anisotropic traveltime fields and ray tracing module</span>
<span class="sd">====================================================</span>

<span class="sd">This is a module uses ALI-FMM for modeling traveltime fields and ray paths in anisotropic media.</span>

<span class="sd">The required python packages are multiprocessing, matplotlib, numpy, math and numba.</span>

<span class="sd">Class should not be used without  if __name__ == &#39;__main__&#39;:  as this may prevent codes from running correctly.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">jit</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="c1"># Parameter used to enable/disable progress bars</span>
<span class="c1">#tqdm_disable = True</span>
<span class="n">tqdm_disable</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="finer_grid_n"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.finer_grid_n">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">finer_grid_n</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for creating a finer grid for a 2D array. Values at each point is the same as the closest point in the original grid.</span>

<span class="sd">    :param veln: Array that finer grid is created from.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param scale: How much the grid size is increased by in each direction.</span>
<span class="sd">    :type scale: Odd integer</span>
<span class="sd">    :param dtype: Data type of the new array. Since function uses numba njit, dtype must be from numba. Default is numba.int32</span>
<span class="sd">    :type dtype: data type</span>
<span class="sd">    :return: 2D numpy array: Finer grid.</span>
<span class="sd">    :rtype: 2D numpy array of type dtype</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the new dimensions of the new grid and create array</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">new_dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_veln</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1">#new_veln = np.zeros(new_dim, dtype=int)</span>

    <span class="c1"># For each point in the original grid assign all surrounding points closest to that point in the new grid are assigned with the same value.</span>
    <span class="n">side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="n">side</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">side</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="n">side</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">side</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_veln</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">veln</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="c1">#new_veln[left:right + 1, bottom:top + 1] = veln[i, j] * np.ones((right - left + 1, top - bottom + 1), dtype=int)</span>
    <span class="k">return</span> <span class="n">new_veln</span></div>


<div class="viewcode-block" id="finer_grid_n_2"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.finer_grid_n_2">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">finer_grid_n_2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for creating a finer grid from a 3D array of material parameters (c_22, c_23, c_33, c_44, density). If None is input None is returned.</span>

<span class="sd">    :param data: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter in order (c_22, c_23, c_33, c_44, density)</span>
<span class="sd">    :type data: 3D numpy array of type int64</span>
<span class="sd">    :param scale: How much the grid size is increased by.</span>
<span class="sd">    :type scale: Odd integer</span>
<span class="sd">    :return: Material parameters at all points in the finer grid. None if data=None</span>
<span class="sd">    :rtype: 3D numpy array of type int64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if None is input None is returned.</span>
    <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Determine the new dimensions of the new grid and create array</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">new_dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">new_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="c1">#new_veln = np.zeros(new_dim, dtype=int)</span>

        <span class="c1"># For each point in the original grid assign all surrounding points closest to that point in the new grid are assigned with the same material parameters.</span>
        <span class="n">side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="n">side</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">side</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="n">side</span><span class="p">)</span>
                <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">side</span><span class="p">,</span> <span class="n">new_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">new_data</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_data</span></div>


<div class="viewcode-block" id="addtree"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.addtree">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for adding a new value to the minimum heap.</span>

<span class="sd">    :param iz: z index of point being added to heap.</span>
<span class="sd">    :type iz: int</span>
<span class="sd">    :param ix: x index of point being added to heap.</span>
<span class="sd">    :type ix: int</span>
<span class="sd">    :param nsts: Note status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param btg: Array for storing the positions of points in the min heap.</span>
<span class="sd">    :type btg: 2D numpy array of type int</span>
<span class="sd">    :param ntr: Number of points on the min heap.</span>
<span class="sd">    :type ntr: int</span>
<span class="sd">    :param ttn: Current travel times at all points in the grid (0 for &quot;far&quot; points).</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :return: nsts, btg, ntr - Updated values of the parameters nsts, btg and ntr</span>
<span class="sd">    :rtype: 2D numpy array of type int, 2D numpy array of type int, int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Increase the size of the tree by one.</span>
    <span class="n">ntr</span> <span class="o">=</span> <span class="n">ntr</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># Put new value at base of tree</span>
    <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ntr</span>
    <span class="n">btg</span><span class="p">[</span><span class="n">ntr</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ix</span>
    <span class="n">btg</span><span class="p">[</span><span class="n">ntr</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iz</span>

    <span class="c1"># Now filter the new value up to its correct position</span>
    <span class="n">tpc</span> <span class="o">=</span> <span class="n">ntr</span>  <span class="c1"># Tree position of parent node.</span>
    <span class="n">tpp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">tpc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Tree position of child node.</span>
    <span class="k">while</span> <span class="n">tpp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Get i, j coordinates of parent node</span>
        <span class="n">aa</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">]:</span>  <span class="c1"># Check whether to swap new point with the parent node/</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">tpp</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tpc</span>
            <span class="n">exch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:])</span>  <span class="c1"># temporary value for swapping values</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">exch</span>
            <span class="n">tpc</span> <span class="o">=</span> <span class="n">tpp</span>  <span class="c1"># Set position of new point to parents (swapped).</span>
            <span class="n">tpp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">tpc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Find position in binary tree of new parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tpp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span></div>


<div class="viewcode-block" id="updtree"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.updtree">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ttn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates the value of a point in a min heap and and filters value to new position in binary tree.</span>

<span class="sd">    :param iz: z index of point being updated.</span>
<span class="sd">    :type iz: int</span>
<span class="sd">    :param ix: x index of point being updated.</span>
<span class="sd">    :type ix: int</span>
<span class="sd">    :param nsts: Node status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param btg: Positions of points in the min heap.</span>
<span class="sd">    :type btg: 2D numpy array of type int</span>
<span class="sd">    :param ttn: Current travel time at all points in the grid (0 for far points).</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :return: nsts, btg - Updated values of parameters nsts and btg.</span>
<span class="sd">    :rtype: 2D numpy array of type int, 2D numpy array of type int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tpc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>  <span class="c1"># Position in the binary tree of the point being updated.</span>
    <span class="n">tpp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">tpc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Position in the binary tree of the parent node.</span>

    <span class="c1"># Filter point to new position in binary tree.</span>
    <span class="k">while</span> <span class="n">tpp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]:</span>  <span class="c1"># Check if child and parent nodes should be swapped.</span>
            <span class="c1"># Swap nodes</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">tpp</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tpc</span>
            <span class="n">exch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:])</span>  <span class="c1"># Temp value for swapping nodes.</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">exch</span>
            <span class="n">tpc</span> <span class="o">=</span> <span class="n">tpp</span>
            <span class="n">tpp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">tpc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tpp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span></div>


<div class="viewcode-block" id="downtree"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.downtree">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">downtree</span><span class="p">(</span><span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for removing the root of the min heap and filtering points into correct positions. Root is replaced by the point at the bottom of the tree and then filtered down.</span>

<span class="sd">    :param nsts: Node status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param btg: Positions of points in the min heap.</span>
<span class="sd">    :type btg: 2D numpy array of type int</span>
<span class="sd">    :param ntr: Number of points in binary tree.</span>
<span class="sd">    :type ntr: int</span>
<span class="sd">    :param ttn: Current travel time at all points in the grid (0 for far points).</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :return: nsts, btg, ntr, ttn - Updated values of parameters nsts, btg, ntr and ttn.</span>
<span class="sd">    :rtype: 2D numpy array of type int, 2D numpy array of type int, int, 2D numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ntr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If removing last point in the tree.</span>
        <span class="n">ntr</span> <span class="o">=</span> <span class="n">ntr</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span>

    <span class="c1"># Replace root of tree with the point in the last position and decrease tree size.</span>
    <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">ntr</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">ntr</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">btg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">btg</span><span class="p">[</span><span class="n">ntr</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">ntr</span> <span class="o">=</span> <span class="n">ntr</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Filter new root down to its correct position.</span>
    <span class="n">tpp</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Position in binary tree of parent node.</span>
    <span class="n">tpc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tpp</span>  <span class="c1"># Position in binary tree of parent node.</span>
    <span class="k">while</span> <span class="n">tpc</span> <span class="o">&lt;</span> <span class="n">ntr</span><span class="p">:</span>
        <span class="c1"># Find smallest value of the two child nodes.</span>
        <span class="n">rd1</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">rd2</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">rd1</span> <span class="o">&gt;</span> <span class="n">rd2</span><span class="p">:</span>
            <span class="n">tpc</span> <span class="o">=</span> <span class="n">tpc</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Check whether the child is smaller than the parent; if so, then swap, if not, then we are done.</span>
        <span class="n">rd1</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">rd2</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">rd1</span> <span class="o">&lt;</span> <span class="n">rd2</span><span class="p">:</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tpc</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tpp</span>
            <span class="n">exch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">exch</span>
            <span class="n">tpp</span> <span class="o">=</span> <span class="n">tpc</span>
            <span class="n">tpc</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tpp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tpc</span> <span class="o">=</span> <span class="n">ntr</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># If ntr is an even number, then we still have one more test to do.</span>
    <span class="k">if</span> <span class="n">tpc</span> <span class="o">==</span> <span class="n">ntr</span><span class="p">:</span>
        <span class="n">rd1</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">rd2</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">rd1</span> <span class="o">&lt;</span> <span class="n">rd2</span><span class="p">:</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tpc</span>
            <span class="n">nsts</span><span class="p">[</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tpp</span>
            <span class="n">exch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">btg</span><span class="p">[</span><span class="n">tpp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">exch</span>
    <span class="k">return</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span></div>


<div class="viewcode-block" id="fouds18_A"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.fouds18_A">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finite difference method for calculating first arrival travel time at iz, ix from travel times of surrounding points with travel time estimates (not all points have an assigned travel time. Uses finite difference method from Anisotropic Multi-Stencil Fast Marching Method (from tant et al 2020 (Effective grain orientation mapping ....)).</span>

<span class="sd">    :param iz: z index of point being updated.</span>
<span class="sd">    :type iz: int</span>
<span class="sd">    :param ix: x index of point being updated.</span>
<span class="sd">    :type ix: int</span>
<span class="sd">    :param nsts: Node status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param ttn: Current travel time at all points in the grid (0 for far points).</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param dnz: Distance between points in the grid in the z direction.</span>
<span class="sd">    :type dnz: float</span>
<span class="sd">    :param nnx: Number of points in the grid in the x direction.</span>
<span class="sd">    :type nnx: int</span>
<span class="sd">    :param nnz: Number of points in the grid in the z direction.</span>
<span class="sd">    :type nnz: int</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points (0 if using stiffness tensors and density, otherwise index for column in avlist2).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Values used for scaling velocities at all grid points (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param avlist2: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type avlist2: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">    :return: Travel time estimate at the point iz, ix.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1"># ! Inspect each of the four quadrants for the minimum time</span>
    <span class="c1"># ! solution.</span>

    <span class="c1"># CALCULATE 2ND ORDER TRAVEL TIMES ON 0DEG STENCIL</span>

    <span class="n">tsw1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">travm</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wave_ang</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># KT 31 / 5 / 17 calculate ray angle between neighbouring alive point and node for determination</span>
    <span class="c1"># eff_ang = round(mod(wave_ang - veln(iz, ix), 90)) # !KT 31 / 15 / 17 effective angle by subtracting cell</span>
    <span class="c1"># orientation from ray angle</span>
    <span class="n">eff_ang</span> <span class="o">=</span> <span class="p">(</span><span class="n">wave_ang</span> <span class="o">-</span> <span class="n">veln</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">%</span> <span class="mi">180</span>
    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">stif_den</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span>
        <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_ang</span> <span class="o">-</span> <span class="n">angle1</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solves christoffel equation to find group velocity.</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
            <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>

    <span class="n">slown</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">velocity</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># j=ix-1:2: ix + 1</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">swj</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j2</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swj</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j2</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j2</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swj</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">swj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">swj</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">]:</span>
                    <span class="n">swj</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">swj</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># k=iz-1:2: iz + 1</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">swk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">k2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">swk</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">k2</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">swk</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">swk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]:</span>
                            <span class="n">swk</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">swk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">swsol</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">swj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">swk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">18</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span>
                                    <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">dnz</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">18</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span>
                                    <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">v</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#############################</span>
                            <span class="c1">#v = dnx</span>
                            <span class="c1">#a = 13</span>
                            <span class="c1">#b = - 8.0 * ttn[k, ix] - 6.0 * (4.0 * ttn[iz, j] - ttn[iz, j2])</span>
                            <span class="c1">#c = 4.0 * ttn[k, ix] ** 2 + (</span>
                            <span class="c1">#            4.0 * ttn[iz, j] - ttn[iz, j2]) ** 2 - 4 * v ** 2 * slown ** 2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">3.0</span>
                            <span class="c1">#u = dnx</span>
                            <span class="c1">#a = 9.0</span>
                            <span class="c1">#b = 0.0</span>
                            <span class="c1">#c = -1 * (4.0 * ttn[iz, j] - ttn[iz, j2]) ** 2 + 3 * (u * slown) ** 2</span>
                            <span class="c1">#tref = 0.0  # 4.0 * ttn[iz, j] - ttn[iz, j2]</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">swk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">dnx</span>
                            <span class="n">em</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">18</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">em</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span>
                                        <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">##########################################</span>
                            <span class="c1">#u = dnx</span>
                            <span class="c1">#a = 13.0</span>
                            <span class="c1">#b = - 6.0 * (4.0 * ttn[k, ix] - ttn[k2, ix]) - 8.0 * 3.0 * ttn[iz, j]</span>
                            <span class="c1">#c = (4.0 * ttn[k, ix] - ttn[k2, ix]) ** 2 + 4.0 * ttn[iz, j] ** 2 - 4 * (u * slown) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">dnx</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">dnz</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">slown</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">slown</span> <span class="o">*</span> <span class="n">dnx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">swk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dnz</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="c1">#########################################</span>
                            <span class="c1">#a = 9.0</span>
                            <span class="c1">#b = 0.0</span>
                            <span class="c1">#c = -(4.0 * ttn[k, ix] - ttn[k2, ix] + (u * slown)) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="n">slown</span> <span class="o">*</span> <span class="n">dnz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="c1"># Now find the solution of the quadratic equation</span>
                    <span class="k">if</span> <span class="n">swsol</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">rd1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
                        <span class="k">if</span> <span class="n">rd1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">rd1</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">tdsh</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rd1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                        <span class="n">trav</span> <span class="o">=</span> <span class="p">(</span><span class="n">tref</span> <span class="o">+</span> <span class="n">tdsh</span><span class="p">)</span> <span class="o">/</span> <span class="n">tdiv</span>
                        <span class="k">if</span> <span class="n">tsw1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">travm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">trav</span><span class="p">,</span> <span class="n">travm</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">travm</span> <span class="o">=</span> <span class="n">trav</span>
                            <span class="n">tsw1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#</span>
    <span class="c1"># if travm~=0</span>
    <span class="c1"># ttn(iz, ix) = min(travm, trav);</span>
    <span class="c1"># else</span>
    <span class="c1"># ttn(iz, ix) = trav;</span>
    <span class="c1"># end</span>

    <span class="n">tsw2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">travmd</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wave_ang</span> <span class="o">=</span> <span class="mi">45</span>  <span class="c1"># KT 31 / 5 / 17 calculate ray angle between neighbouring alive point and node for determination</span>
    <span class="n">eff_ang</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">wave_ang</span> <span class="o">-</span> <span class="n">veln</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span>  <span class="c1"># round(mod(wave_ang - veln(iz, ix), 90)) # !KT 31 / 15 / 17</span>
    <span class="c1"># effective angle by subtracting cell orientation from ray angle</span>
    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">stif_den</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span>
        <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_ang</span> <span class="o">-</span> <span class="n">angle1</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solves christoffel equation to find group velocity.</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
            <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>

    <span class="n">slown</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">velocity</span>
    <span class="n">mf2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># distance between two diagonally connected points</span>

    <span class="c1"># start with diag axes of stencil</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># j=ix-1:2: ix + 1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">swdiag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j2</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k2</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swdiag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j2</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j2</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">k2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swdiag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">swdiag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">swdiag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]:</span>
                    <span class="n">swdiag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">swdiag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># skew diag axis</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># jj=ix-1:2: ix + 1</span>
                <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">kk</span> <span class="o">=</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kk</span> <span class="o">=</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">swskew</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">jj2</span> <span class="o">=</span> <span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">kk2</span> <span class="o">=</span> <span class="n">kk</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">jj2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">kk2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">swskew</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">jj</span> <span class="o">==</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">jj2</span> <span class="o">=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">kk2</span> <span class="o">=</span> <span class="n">kk</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">jj2</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kk2</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">swskew</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">swskew</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swskew</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">]:</span>
                            <span class="n">swskew</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">swskew</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">swsol</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">swdiag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">swskew</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">18.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">])</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span>
                                        <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="c1">#u = mf2 * dnx</span>
                            <span class="c1">#a = 18.0</span>
                            <span class="c1">#b = -6.0 * (4.0 * ttn[k, j] - ttn[k2, j2] + 4.0 * ttn[kk, jj] - ttn[kk2, jj2])</span>
                            <span class="c1">#c = (4.0 * ttn[k, j] - ttn[k2, j2]) ** 2 + (</span>
                            <span class="c1">#        4.0 * ttn[kk, jj] - ttn[kk2, jj2]) ** 2 - 4 * u ** 2 * slown ** 2</span>
                            <span class="c1">#tref = 0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1">#v = mf2 * dnx          ###wrong index</span>
                            <span class="c1">#a = 45</span>
                            <span class="c1">#b = -6.0 * (12.0 * ttn[k, ix] + 4.0 * ttn[iz, j] - ttn[iz, j2])</span>
                            <span class="c1">#c = (6.0 * ttn[k, ix]) ** 2 + (</span>
                            <span class="c1">#        4.0 * ttn[iz, j] - ttn[iz, j2]) ** 2 - 16 * v ** 2 * slown ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnz</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">18</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span>
                                    <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">v</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="c1">#v = mf2 * dnx</span>
                            <span class="c1">#a = 13</span>
                            <span class="c1">#b = -6.0 * (4.0 * ttn[iz, j] - ttn[iz, j2]) - 8.0 * ttn[k, ix]</span>
                            <span class="c1">#c = 4.0 * ttn[k, ix] ** 2 + (4.0 * ttn[iz, j] - ttn[iz, j2]) ** 2 - 4.0 * (v * slown) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">slown</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k2</span><span class="p">,</span> <span class="n">j2</span><span class="p">])</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">3.0</span>
                            <span class="c1">#u = mf2 * dnx</span>
                            <span class="c1">#a = 9.0</span>
                            <span class="c1">#b = 0.0</span>
                            <span class="c1">#c = -(4.0 * ttn[k, j] - ttn[k2, j2]) ** 2 + 3 * (u * slown) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                    <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">swskew</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dnz</span>
                            <span class="n">em</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">]</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">18</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">em</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="c1">#u = mf2 * dnx</span>
                            <span class="c1">#a = 13</span>
                            <span class="c1">#b = -6.0 * (4.0 * ttn[kk, jj] - ttn[kk2, jj2]) - 8.0 * ttn[k, j]</span>
                            <span class="c1">#c = (4.0 * ttn[kk, jj] - ttn[kk2, jj2]) ** 2 + 4.0 * ttn[k, j] ** 2 - 4.0 * (u * slown) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnz</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">9</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">slown</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="c1">#u = mf2 * dnx</span>
                            <span class="c1">#a = 2</span>
                            <span class="c1">#b = -2 * (ttn[kk, jj] + ttn[k, j])</span>
                            <span class="c1">#c = ttn[kk, jj] ** 2 + ttn[k, j] ** 2 - (u * slown) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">slown</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">swskew</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnz</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk2</span><span class="p">,</span> <span class="n">jj2</span><span class="p">]</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">3.0</span>
                            <span class="c1">#u = mf2 * dnx</span>
                            <span class="c1">#a = 9.0</span>
                            <span class="c1">#b = 0.0</span>
                            <span class="c1">#c = -1.0 * (4.0 * ttn[kk, jj] - ttn[kk2, jj2] + u * slown) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">slown</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                            <span class="n">tdiv</span> <span class="o">=</span> <span class="mf">1.0</span>
                            <span class="c1">#u = mf2 * dnx</span>
                            <span class="c1">#a = 1.0</span>
                            <span class="c1">#b = 0.0</span>
                            <span class="c1">#c = -(ttn[kk, jj] + slown * u) ** 2</span>
                            <span class="c1">#tref = 0.0</span>
                            <span class="c1">#tdiv = 1.0</span>

                    <span class="c1"># Now find the solution of the quadratic equation</span>
                    <span class="k">if</span> <span class="n">swsol</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">rd1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
                        <span class="k">if</span> <span class="n">rd1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">tdsh</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rd1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                            <span class="n">trav</span> <span class="o">=</span> <span class="p">(</span><span class="n">tref</span> <span class="o">+</span> <span class="n">tdsh</span><span class="p">)</span> <span class="o">/</span> <span class="n">tdiv</span>
                            <span class="k">if</span> <span class="n">tsw2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">travmd</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">trav</span><span class="p">,</span> <span class="n">travmd</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">travmd</span> <span class="o">=</span> <span class="n">trav</span>
                                <span class="n">tsw2</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">travmd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">travmd</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">travm</span><span class="p">,</span> <span class="n">travmd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">travmd</span> <span class="o">=</span> <span class="n">travm</span>

    <span class="n">tsw3</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">travmt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># wave_ang = round(atand(0.5)) #% KT 31 / 5 / 17 calculate ray angle between neighbouring alive</span>
    <span class="c1"># point and node for determination</span>
    <span class="n">wave_ang</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)))</span>
    <span class="c1"># eff_ang using fact that arctan(0.5) + arctan(2) = 90 so arctan(2) = -arctan(0.5) % 90</span>
    <span class="n">eff_ang</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">wave_ang</span> <span class="o">-</span> <span class="n">veln</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">%</span> <span class="mi">180</span>  <span class="c1"># !KT 31 / 15 / 17</span>
    <span class="c1"># effective angle by subtracting cell orientation from ray angle</span>
    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">stif_den</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span>
        <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_ang</span> <span class="o">-</span> <span class="n">angle1</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solves christoffel equation to find group velocity.</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
            <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>

    <span class="n">slown</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">velocity</span>

    <span class="n">mf2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># distance between two diagonally connected points</span>

    <span class="n">j_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">k_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>  <span class="c1"># lp=1:4</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j_vec</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k_vec</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span>
        <span class="n">jj</span> <span class="o">=</span> <span class="n">j_vec</span><span class="p">[</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="n">k_vec</span><span class="p">[</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># !There are seven solution options in each quadrant.</span>
                        <span class="n">swsol</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>  <span class="c1"># !KT 17 / 5 / 17 diagonal nodes are sqrt(2) * dnx from</span>
                                <span class="c1"># active node (isotropic grid spacing only)</span>
                                <span class="n">v</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnz</span>
                                <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                                <span class="n">c</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">slown</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                <span class="c1"># em = ttn(kk, jj) - ttn(k, j);</span>
                                <span class="c1"># a = v ** 2 + u ** 2;</span>
                                <span class="c1"># b = -2.0 * u ** 2 * em;</span>
                                <span class="c1"># c = u ** 2 * (em ** 2 - v ** 2 * slown ** 2);</span>
                                <span class="n">tref</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                                <span class="c1"># v = u;</span>
                                <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">slown</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                <span class="n">tref</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>  <span class="c1"># !KT 30 / 1 / 17</span>
                            <span class="c1"># v = sqrt(2.0) * dnz</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">slown</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                        <span class="c1"># Now find the solution of the quadratic equation</span>
                        <span class="k">if</span> <span class="n">swsol</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">rd1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
                            <span class="k">if</span> <span class="n">rd1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">rd1</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">tdsh</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rd1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                            <span class="n">trav</span> <span class="o">=</span> <span class="n">tref</span> <span class="o">+</span> <span class="n">tdsh</span>
                            <span class="k">if</span> <span class="n">tsw3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">travmt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">trav</span><span class="p">,</span> <span class="n">travmt</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">travmt</span> <span class="o">=</span> <span class="n">trav</span>
                                <span class="n">tsw3</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">travmt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">travmt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">travmt</span><span class="p">,</span> <span class="n">travmd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">travmt</span> <span class="o">=</span> <span class="n">travmd</span>

    <span class="n">tsw4</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">travms</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># eff_ang = round(mod(wave_ang - veln(iz, ix), 90)) # !KT 31 / 15 / 17 effective angle by</span>
    <span class="c1"># subtracting cell orientation from ray angle</span>
    <span class="n">eff_ang</span> <span class="o">=</span> <span class="p">(</span><span class="n">wave_ang</span> <span class="o">-</span> <span class="n">veln</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span> <span class="o">%</span> <span class="mi">180</span>
    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">stif_den</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span>
        <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_ang</span> <span class="o">-</span> <span class="n">angle1</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solves christoffel equation to find group velocity.</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
            <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>

    <span class="n">slown</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">velocity</span>
    <span class="n">mf2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># distance between two diagonally connected points</span>

    <span class="n">j_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">k_vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>  <span class="c1"># lp=1:4</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j_vec</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k_vec</span><span class="p">[</span><span class="n">lp</span><span class="p">]</span>
        <span class="n">jj</span> <span class="o">=</span> <span class="n">j_vec</span><span class="p">[</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="n">k_vec</span><span class="p">[</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># !There are seven solution options in each quadrant.</span>
                        <span class="n">swsol</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>  <span class="c1"># !KT 17 / 5 / 17 diagonal nodes are sqrt(2) * dnx from</span>
                                <span class="c1"># active node (isotropic grid spacing only)</span>
                                <span class="n">v</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnz</span>
                                <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
                                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                                <span class="n">c</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">slown</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                <span class="c1"># em = ttn[kk, jj] - ttn[k, j]</span>
                                <span class="c1"># a = v ** 2 + u ** 2</span>
                                <span class="c1"># b = -2.0 * u ** 2 * em</span>
                                <span class="c1"># c = u ** 2 * (em ** 2 - v ** 2 * slown ** 2)</span>
                                <span class="n">tref</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>
                                <span class="c1"># v = u;</span>
                                <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">slown</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                <span class="n">tref</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">swsol</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">mf2</span> <span class="o">*</span> <span class="n">dnx</span>  <span class="c1"># !KT 30 / 1 / 17</span>
                            <span class="c1"># v = sqrt(2.0) * dnz;</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">slown</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="n">tref</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                        <span class="c1"># !Now find the solution of the quadratic equation</span>
                        <span class="k">if</span> <span class="n">swsol</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">rd1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
                            <span class="k">if</span> <span class="n">rd1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">rd1</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">tdsh</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rd1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                            <span class="n">trav</span> <span class="o">=</span> <span class="n">tref</span> <span class="o">+</span> <span class="n">tdsh</span>
                            <span class="k">if</span> <span class="n">tsw4</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">travms</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">trav</span><span class="p">,</span> <span class="n">travms</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">travms</span> <span class="o">=</span> <span class="n">trav</span>
                                <span class="n">tsw4</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">travms</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">travms</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">travmt</span><span class="p">,</span> <span class="n">travms</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">travms</span> <span class="o">=</span> <span class="n">travmt</span>
    <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">travms</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">travms</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
    <span class="c1">#ttn[iz, ix] = travms</span>
    <span class="k">return</span> <span class="n">travms</span></div>


<div class="viewcode-block" id="update"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.update">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Our finite difference method for calculating first arrival travel time at point with indices iz, ix from travel times at surrounding points with travel time estimates (not all points have an associated travel time).</span>

<span class="sd">    :param veln: Anisotropic orientation of all grid points.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param nsts: Node status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param ttn: Current travel time at all points in the grid (0 for far points).</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :param iz: z index of point where finite difference is applied.</span>
<span class="sd">    :type iz: int</span>
<span class="sd">    :param ix: x index of point where finite difference is applied.</span>
<span class="sd">    :type ix: int</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x/z direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param nnz: Number of points in the grid in the z direction.</span>
<span class="sd">    :type nnz: int</span>
<span class="sd">    :param nnx: Number of points in the grid in the x direction.</span>
<span class="sd">    :type nnx: int</span>
<span class="sd">    :param phase_vel: Phase velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type phase_vel: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">    :return: Travel time estimate at the point iz, ix.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First we check which square stencils can be used.</span>
    <span class="n">sten_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># Array for soring how many points required for the stencil have travel time estimates</span>
    <span class="c1">#sten_points = np.zeros(8, dtype=int)</span>
    <span class="c1"># We find the number of points in each stencil with can be used in the finite difference method.</span>
    <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># These parameters keep track of the minimum difference and which stencil had the minimum. If they are unchanged then there are no suitable square stencils.</span>
    <span class="n">stencil_no</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">min_diff</span> <span class="o">=</span> <span class="mf">1000000.0</span>

    <span class="c1"># We go through all square stencils and check if it is possible to use it(all points have travel time estimates) and</span>
    <span class="c1"># find the difference in travel time between two points. The stencil with the minimum is used for the finite difference.</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
            <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">7</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
    <span class="c1">#print(&quot;Stencil_points :&quot;, sten_points)</span>
    <span class="c1">#print(&quot;Sten no :&quot;, stencil_no)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">stencil_no</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># If we have a valid stencil we find which stencil in a stencil pair we can use (all stencils are in pairs where only one can be used and use the same points and same value for the difference in the previous section of code) and calculate the angle of the wavefront and the distance to the point we are calculating.</span>
        <span class="k">if</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix, ix - 1, ix + 1, ix, iz - 2, iz - 1, iz - 1, iz - 1, ttn[iz - 2, ix], ttn[iz - 1, ix - 1], ttn[iz - 1, ix + 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz - 1, ix]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix, ix + 1, ix - 1, ix, iz - 2, iz - 1, iz - 1, iz - 1, ttn[iz - 2, ix], ttn[iz - 1, ix + 1], ttn[iz - 1, ix - 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz - 1, ix]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix + 2, ix + 1, ix + 1, ix + 1, iz, iz - 1, iz + 1, iz, ttn[iz, ix + 2], ttn[iz - 1, ix + 1], ttn[iz + 1, ix + 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz, ix + 1]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix + 2, ix + 1, ix + 1, ix + 1, iz, iz + 1, iz - 1, iz, ttn[iz, ix + 2], ttn[iz + 1, ix + 1], ttn[iz - 1, ix + 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz, ix + 1]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix, ix - 1, ix + 1, ix, iz + 2, iz + 1, iz + 1, iz + 1, ttn[iz + 2, ix], ttn[iz + 1, ix - 1], ttn[iz + 1, ix + 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz + 1, ix]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix, ix + 1, ix - 1, ix, iz + 2, iz + 1, iz + 1, iz + 1, ttn[iz + 2, ix], ttn[iz + 1, ix + 1], ttn[iz + 1, ix - 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz + 1, ix]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix - 2, ix - 1, ix - 1, ix - 1, iz, iz - 1, iz + 1, iz, ttn[iz, ix - 2], ttn[iz - 1, ix - 1], ttn[iz + 1, ix - 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz, ix - 1]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist_diamond(ix, iz, ix - 2, ix - 1, ix - 1, ix - 1, iz, iz + 1, iz - 1, iz, ttn[iz, ix - 2], ttn[iz + 1, ix - 1], ttn[iz - 1, ix - 1])</span>
                    <span class="c1">#wavefront_time = ttn[iz, ix - 1]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>

    <span class="c1"># If no stencils were valid or the grid point is at the edge of the grid we check the triangular stencils.</span>
    <span class="k">if</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">ix</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ix</span> <span class="o">==</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">iz</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">iz</span> <span class="o">==</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">#else:</span>
        <span class="c1">#print(&quot;try stencils 8-15&quot;)</span>

        <span class="c1"># We find number of points in the stencils which can be used.</span>
        <span class="n">sten_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="c1">#sten_points = np.zeros(8, dtype=int)</span>
        <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">iz</span> <span class="o">&lt;</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># We look at all valid stencils and find how close the travel times are to the case when our estimated wavefront has perpendicular bisector passing through the point where we are finding the estimated travel time.</span>
        <span class="k">if</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">min_diff</span> <span class="o">=</span> <span class="mf">1000000.0</span>
        <span class="n">stencil_no</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz + 1, ix] - ttn[iz + 1, ix + 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz - 1, ix] - ttn[iz - 1, ix + 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz - 1, ix] - ttn[iz - 1, ix - 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz + 1, ix] - ttn[iz + 1, ix - 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">3</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz, ix - 1] - ttn[iz + 1, ix - 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">4</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz, ix + 1] - ttn[iz + 1, ix + 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">5</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz, ix + 1] - ttn[iz - 1, ix + 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">6</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="k">if</span> <span class="n">sten_points</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1">#diff = ttn[iz, ix - 1] - ttn[iz - 1, ix - 1]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">:</span>
                    <span class="n">stencil_no</span> <span class="o">=</span> <span class="mi">7</span>
                    <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span>
        <span class="c1">#    stencil_no = -1</span>
        <span class="k">if</span> <span class="n">stencil_no</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1">#  If any stencils are valid, we select the valid stencil in the chosen stencil pair and use it to calculate the angle of the estimated wavefront and the minimum distance to the point we are estimating.</span>
            <span class="k">if</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix, ix + 1, iz + 2, iz + 1, iz + 1, ttn[iz + 2, ix], ttn[iz + 1, ix], ttn[iz + 1, ix + 1], 1, -(math.sqrt(2) - 1))</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix + 1, ix, iz + 2, iz + 1, iz + 1, ttn[iz + 2, ix], ttn[iz + 1, ix + 1], ttn[iz + 1, ix], 1, -(math.sqrt(2) - 1))</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix, ix + 1, iz - 2, iz - 1, iz - 1, ttn[iz - 2, ix], ttn[iz - 1, ix], ttn[iz - 1, ix + 1], 1, (math.sqrt(2) - 1))</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix + 1, ix, iz - 2, iz - 1, iz - 1, ttn[iz - 2, ix], ttn[iz - 1, ix + 1], ttn[iz - 1, ix], 1, (math.sqrt(2) - 1))</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ix</span> <span class="o">==</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix, ix - 1, iz - 2, iz - 1, iz - 1, ttn[iz - 2, ix], ttn[iz - 1, ix], ttn[iz - 1, ix - 1], 1, -(math.sqrt(2) - 1))</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix - 1, ix, iz - 2, iz - 1, iz - 1, ttn[iz - 2, ix], ttn[iz - 1, ix - 1], ttn[iz - 1, ix], 1, -(math.sqrt(2) - 1))</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ix</span> <span class="o">==</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix, ix - 1, iz + 2, iz + 1, iz + 1, ttn[iz + 2, ix], ttn[iz + 1, ix], ttn[iz + 1, ix - 1], 1, (math.sqrt(2) - 1))</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix, ix - 1, ix, iz + 2, iz + 1, iz + 1, ttn[iz + 2, ix], ttn[iz + 1, ix - 1], ttn[iz + 1, ix], 1, (math.sqrt(2) - 1))</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">iz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix - 2, ix - 1, ix - 1, iz, iz, iz + 1, ttn[iz, ix - 2], ttn[iz, ix - 1], ttn[iz + 1, ix - 1], (math.sqrt(2) - 1), 1)</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix - 2, ix - 1, ix - 1, iz, iz + 1, iz, ttn[iz, ix - 2], ttn[iz + 1, ix - 1], ttn[iz, ix - 1], (math.sqrt(2) - 1), 1)</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">iz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix + 2, ix + 1, ix + 1, iz, iz, iz + 1, ttn[iz, ix + 2], ttn[iz, ix + 1], ttn[iz + 1, ix + 1], -(math.sqrt(2) - 1), 1)</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix + 2, ix + 1, ix + 1, iz, iz + 1, iz, ttn[iz, ix + 2], ttn[iz + 1, ix + 1], ttn[iz, ix + 1], -(math.sqrt(2) - 1), 1)</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">iz</span> <span class="o">==</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix + 2, ix + 1, ix + 1, iz, iz, iz - 1, ttn[iz, ix + 2], ttn[iz, ix + 1], ttn[iz - 1, ix + 1], (math.sqrt(2) - 1), 1)</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix + 2, ix + 1, ix + 1, iz, iz - 1, iz, ttn[iz, ix + 2], ttn[iz - 1, ix + 1], ttn[iz, ix + 1], (math.sqrt(2) - 1), 1)</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">stencil_no</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">iz</span> <span class="o">==</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix - 2, ix - 1, ix - 1, iz, iz, iz - 1, ttn[iz, ix - 2], ttn[iz, ix - 1], ttn[iz - 1, ix - 1], -(math.sqrt(2) - 1), 1)</span>
                        <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#angle, dist = wavefront_angle_dist2(ix, iz, ix - 2, ix - 1, ix - 1, iz, iz - 1, iz, ttn[iz, ix - 2], ttn[iz - 1, ix - 1], ttn[iz, ix - 1], -(math.sqrt(2) - 1), 1)</span>
                    <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">wavefront_time</span> <span class="o">=</span> <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">stencil_no</span> <span class="o">+=</span> <span class="mi">8</span>
    <span class="k">if</span> <span class="n">dist</span> <span class="o">!=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If there is a valid stencil.</span>
        <span class="n">eff_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>  <span class="c1"># Apply a rotation to the angle to match the orientation of the material at that point (only used for calculate velocities.</span>

        <span class="c1"># If we are not using stiffness tensors then we use the table of phase velocities to find the volocity for the given angle</span>
        <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">stif_den</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1">#if velpn[iz, ix] != 0 or type(stif_den) == type(None):</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">)</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_angle</span> <span class="o">-</span> <span class="n">angle1</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">phase_vel</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">phase_vel</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if eff_angle % 90 == 0:</span>
            <span class="c1">#    if eff_angle == 90:</span>
            <span class="c1">#        val_lambda = stif_den[iz, ix, 2]</span>
            <span class="c1">#    else:</span>
            <span class="c1">#        val_lambda = stif_den[iz, ix, 0]</span>
            <span class="c1">#else:</span>
            <span class="c1">#    c_22 = stif_den[iz, ix, 0]</span>
            <span class="c1">#    c_23 = stif_den[iz, ix, 1]</span>
            <span class="c1">#    c_33 = stif_den[iz, ix, 2]</span>
            <span class="c1">#    c_44 = stif_den[iz, ix, 3]</span>
            <span class="c1">#    sigma = stif_den[iz, ix, 4]</span>
            <span class="c1">#    tan_ang = math.tan(math.radians(eff_angle))</span>
            <span class="c1">#    A = c_22 + c_33 - 2 * c_44</span>
            <span class="c1">#    B = (c_23 + c_44) * (tan_ang - 1 / tan_ang)</span>
            <span class="c1">#    C = c_22 - c_33</span>
            <span class="c1">#    if eff_angle &lt; 90:</span>
            <span class="c1">#        phase_angle_rad = math.atan((-B - math.sqrt(B ** 2 + A ** 2 - C ** 2)) / (C - A)) % math.pi</span>
            <span class="c1">#    else:</span>
            <span class="c1">#        phase_angle_rad = math.atan((-B + math.sqrt(B ** 2 + A ** 2 - C ** 2)) / (C - A)) % math.pi</span>
            <span class="c1">#    lambda_val = 0.5 * (math.cos(2 * phase_angle_rad) * (c_22 - c_44) + math.sin(2 * phase_angle_rad) * (c_23 + c_44) * tan_ang + c_22 + c_44)</span>
            <span class="c1">#velocity = vel_map[iz, ix] * math.sqrt(lambda_val / sigma) / math.cos(math.radians(eff_angle) - phase_angle_rad)</span>

            <span class="c1"># Find the phase velociy from the stiffness tensors</span>
            <span class="n">cos_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">))</span>
            <span class="n">sin_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">))</span>
            <span class="c1"># We find the values of a, b and c in the quadratic equation we are solving.</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">cos_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">cos_ang</span> <span class="o">*</span> <span class="n">sin_ang</span> <span class="o">*</span> <span class="p">(</span><span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">cos_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">sin_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">A</span> <span class="o">+</span> <span class="n">C</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">A</span> <span class="o">-</span> <span class="n">C</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">wavefront_time</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="n">dnx</span> <span class="o">/</span> <span class="n">velocity</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if there were no valid stencils we return a travel time of -1.0 to show this.</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span></div>


<div class="viewcode-block" id="wavefront_angle_dist"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.wavefront_angle_dist">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">wavefront_angle_dist</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">z3</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the direction of the normal to the wavefront and the minimum distance between the estimated wavefront and the point we are calculating the travel time for. Stencils have points A, B, C where A&lt;=B&lt;C and the estimated wavefront goes through B.</span>

<span class="sd">    :param ix: Index of the x position at the point where we are estimating a travel time.</span>
<span class="sd">    :type ix: int</span>
<span class="sd">    :param iz: Index of the z position at the point where we are estimating a travel time.</span>
<span class="sd">    :type iz: int</span>
<span class="sd">    :param x1: Index of the x position at the point with label A.</span>
<span class="sd">    :type x1: int</span>
<span class="sd">    :param x2: Index of the x position at the point with label B.</span>
<span class="sd">    :type x2: int</span>
<span class="sd">    :param x3: Index of the x position at the point with label C.</span>
<span class="sd">    :type x3: int</span>
<span class="sd">    :param z1: Index of the z position at the point with label A.</span>
<span class="sd">    :type z1: int</span>
<span class="sd">    :param z2: Index of the z position at the point with label B.</span>
<span class="sd">    :type z2: int</span>
<span class="sd">    :param z3: Index of the z position at the point with label C.</span>
<span class="sd">    :type z3: int</span>
<span class="sd">    :param y1: Travel time estimate at the point with label A.</span>
<span class="sd">    :type y1: float</span>
<span class="sd">    :param y2: Travel time estimate at the point with label B.</span>
<span class="sd">    :type y2: float</span>
<span class="sd">    :param y3: Travel time estimate at the point with label C.</span>
<span class="sd">    :type y3: float</span>
<span class="sd">    :return: angle, dist - The direction of the normal to the estimated wavefront and the minimum distance between the wavefront and the point we are estimating.</span>
<span class="sd">    :rtype: float, float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If possible we use linear interpolation to find the point between A and C with the same travel time as B by solving (1-a)y1 + a(y3) = y2.</span>
    <span class="k">if</span> <span class="n">y3</span> <span class="o">!=</span> <span class="n">y1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y3</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>  <span class="c1"># (1-a)y1 + a(y3) = y2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="c1"># Calculate the position of the point on the estimated wavefront which was obtained using linear interpolation.</span>
    <span class="n">xpos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x3</span>
    <span class="n">zpos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">z1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">z3</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">xpos</span>
    <span class="n">diff_z</span> <span class="o">=</span> <span class="n">z2</span> <span class="o">-</span> <span class="n">zpos</span>
    <span class="c1"># Find the angle of the normal to the wavefront.</span>
    <span class="k">if</span> <span class="n">diff_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">diff_z</span><span class="o">/</span><span class="n">diff_x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
    <span class="c1"># Calculate the minimum distance between the estimated wavefront and the point we are estimating.</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diff_z</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">ix</span><span class="p">)</span> <span class="o">-</span> <span class="n">diff_x</span> <span class="o">*</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">iz</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff_z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">angle</span><span class="p">,</span> <span class="n">dist</span></div>


<div class="viewcode-block" id="travel"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.travel">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">travel</span><span class="p">(</span><span class="n">scx</span><span class="p">,</span> <span class="n">scz</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for calculating a travel time field for a given source.</span>

<span class="sd">    :param scx: x position of the source (gets rounded to the nearest grid point in this implementation).</span>
<span class="sd">    :type scx: float</span>
<span class="sd">    :param scz: z position of the source (gets rounded to the nearest grid point in this implementation).</span>
<span class="sd">    :type scz: float</span>
<span class="sd">    :param nsts: Node status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param btg: Positions of points in the min heap (start with empty binary tree).</span>
<span class="sd">    :type btg: 2D numpy array of type int</span>
<span class="sd">    :param ntr: Number of points in the minimum heap.</span>
<span class="sd">    :type ntr: int</span>
<span class="sd">    :param ttn: Current travel time at all points in the grid. Start with 2D array of zeros</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points. For isotropic material this parameter will not affect anything.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points (0 if using stiffness tensors and density, otherwise index for column in avlist2).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">    :param avlist2: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type avlist2: 2D numpy array</span>
<span class="sd">    :param phase_vel: Phase velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type phase_vel: 2D numpy array</span>
<span class="sd">    :param gox: x position of the point with indices (0, 0).</span>
<span class="sd">    :type gox: float</span>
<span class="sd">    :param goz: z position of the point with indices (0, 0).</span>
<span class="sd">    :type goz: float</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param dnz: Distance between points in the grid in the z direction.</span>
<span class="sd">    :type dnz: float</span>
<span class="sd">    :param nnx: Number of points in the grid in the x direction.</span>
<span class="sd">    :type nnx: int</span>
<span class="sd">    :param nnz: Number of points in the grid in the z direction.</span>
<span class="sd">    :type nnz: int</span>
<span class="sd">    :return: Travel time field for the given source.</span>
<span class="sd">    :rtype: 2D numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We determine the nearest point on the grid from the source and use that point as the source (using the exact source location makes the initial propogation around the source more complex).</span>
    <span class="n">isx</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">scx</span> <span class="o">-</span> <span class="n">gox</span><span class="p">)</span> <span class="o">/</span> <span class="n">dnx</span><span class="p">)</span>  <span class="c1"># round((scx-gox)/dnx)+1</span>
    <span class="n">isz</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">scz</span> <span class="o">-</span> <span class="n">goz</span><span class="p">)</span> <span class="o">/</span> <span class="n">dnz</span><span class="p">)</span>  <span class="c1"># round((scz-goz)/dnz)+1</span>

    <span class="c1"># Set up the variables used around the source for the initial propogation.</span>
    <span class="n">size1</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Size of grid around source for initial propagation</span>
    <span class="n">subgrid_size1</span> <span class="o">=</span> <span class="mi">27</span>  <span class="c1"># Size of subgrid for initial propagation</span>
    <span class="n">side1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx</span> <span class="o">+</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz</span> <span class="o">+</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">temp_isx</span> <span class="o">=</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">left</span>
    <span class="n">temp_isz</span> <span class="o">=</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">bottom</span>
    <span class="n">temp_veln</span> <span class="o">=</span> <span class="n">veln</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">temp_velpn</span> <span class="o">=</span> <span class="n">velpn</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">temp_vel_map</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>


    <span class="n">veln1</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">temp_veln</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">)</span>
    <span class="n">velpn1</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">temp_velpn</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">)</span>
    <span class="n">vel_map1</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">temp_vel_map</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">,</span> <span class="n">numba</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1">#if type(stif_den) != type(None):</span>
    <span class="k">if</span> <span class="n">stif_den</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">temp_stif_den</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">stif_den1</span> <span class="o">=</span> <span class="n">finer_grid_n_2</span><span class="p">(</span><span class="n">temp_stif_den</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stif_den1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ttn1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nsts1</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">veln1</span><span class="p">)</span>
    <span class="n">isx_1</span> <span class="o">=</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="n">temp_isx</span>
    <span class="n">isz_1</span> <span class="o">=</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="n">temp_isz</span>
    <span class="n">dnx1</span> <span class="o">=</span> <span class="n">dnx</span> <span class="o">/</span> <span class="n">subgrid_size1</span>
    <span class="n">nnz1</span> <span class="o">=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnx1</span> <span class="o">=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_dist1</span> <span class="o">=</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="n">size1</span>  <span class="c1"># Maximum distance along horiz and vert</span>

    <span class="c1"># For points on the fine grid which have there material parameters copied from the source point we calculate travel times by straight rays since this region is homogeneous</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">side1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">side1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">diff_z</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="c1"># We find the direction of the straight ray</span>
                    <span class="k">if</span> <span class="n">diff_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="c1">#diff_z == 0:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle = math.degrees(math.atan(diff_x / diff_z))</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">diff_z</span> <span class="o">/</span> <span class="n">diff_x</span><span class="p">))</span>
                    <span class="n">eff_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
                    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If not using stiffness tensors.</span>
                        <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">)</span>
                        <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
                        <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_angle</span> <span class="o">-</span> <span class="n">angle1</span>
                        <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Solving christoffel equation to find group velocities</span>
                        <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">eff_angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_angle</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">))</span>
                            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
                            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">tan_ang</span><span class="p">)</span>
                            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
                            <span class="k">if</span> <span class="n">eff_angle</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
                            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="n">dnx1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_z</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">isz_1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">velocity</span>
                    <span class="n">nsts1</span><span class="p">[</span><span class="n">isz_1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># We set the node status to 0 so that the travel times are in the known state (will not be changed).</span>

    <span class="c1"># We set up the minimum heap structure used for selecting which point to update.</span>
    <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">btg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="c1">#btg1 = np.zeros((maxbt, 2), dtype=int)</span>
    <span class="n">ntr1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sten_no</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># We add all points on the edge of the starting area to the minimum heap so surrounding points can have the finite difference method applied to them. Since node status is 0 these points will not be updated.</span>
    <span class="k">if</span> <span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span> <span class="o">&lt;=</span> <span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span> <span class="o">&lt;=</span> <span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>

    <span class="c1">#plt.imshow(ttn1)</span>
    <span class="c1">#plt.title(&quot;ttn1&quot;)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># While loop that will run until the wavefront encounters the edge of the fine grid around the source.</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">ntr1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">finished</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># ! Set the &quot;close&quot; point with minimum travel time &quot;alive&quot;.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex)</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>

        <span class="c1"># Now update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># =ix-1:2:ix+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># When a far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>

                    <span class="c1"># Add new &quot;close&quot; point to the binary tree.</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
                    <span class="c1"># plt.imshow(ttn)</span>
                    <span class="c1"># plt.show()</span>
                <span class="k">elif</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Updating a &quot;close&quot; point.</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isx_1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># Test points that vary in z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i=iz-1:2:iz+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># When a far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="c1"># plt.imshow(ttn)</span>
                    <span class="c1"># plt.show()</span>
                    <span class="c1"># ttn = fouds18(i, ix, nsts, ttn, dnx, dnz, nnx, nnz, veln, velpn, avlist2)</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Updating a &quot;close&quot; point.</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isz_1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#print(isx_1, isz_1)</span>

    <span class="c1">#plt.imshow(ttn1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn1&quot;)</span>
    <span class="c1">#plt.show()</span>


    <span class="c1"># We set up the variables used for a slightly coarser grid as we get further from the source.</span>
    <span class="n">size2</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Size of grid in each direction around source for propagation (total is 2n+1)</span>
    <span class="n">subgrid_size2</span> <span class="o">=</span> <span class="mi">9</span>  <span class="c1"># Size of subgrid (must be subgrid_size / 3)</span>
    <span class="n">side2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx</span> <span class="o">+</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz</span> <span class="o">+</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">temp_isx</span> <span class="o">=</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">left</span>
    <span class="n">temp_isz</span> <span class="o">=</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">bottom</span>
    <span class="n">veln2</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">)</span>
    <span class="n">velpn2</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">velpn</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">)</span>
    <span class="n">vel_map2</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">vel_map</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">,</span> <span class="n">numba</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1">#if type(stif_den) != type(None):</span>
    <span class="k">if</span> <span class="n">stif_den</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stif_den2</span> <span class="o">=</span> <span class="n">finer_grid_n_2</span><span class="p">(</span><span class="n">stif_den</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stif_den2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ttn2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nsts2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">veln2</span><span class="p">)</span>
    <span class="n">isx_2</span> <span class="o">=</span> <span class="n">subgrid_size2</span> <span class="o">*</span> <span class="n">temp_isx</span>
    <span class="n">isz_2</span> <span class="o">=</span> <span class="n">subgrid_size2</span> <span class="o">*</span> <span class="n">temp_isz</span>
    <span class="n">dnx2</span> <span class="o">=</span> <span class="n">dnx</span> <span class="o">/</span> <span class="n">subgrid_size2</span>
    <span class="n">nnz2</span> <span class="o">=</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnx2</span> <span class="o">=</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_dist2</span> <span class="o">=</span> <span class="n">subgrid_size2</span> <span class="o">*</span> <span class="n">size2</span>  <span class="c1"># Maximum distance along horiz and vert</span>

    <span class="c1"># Set up binary tree</span>
    <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">btg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="c1">#btg2 = np.zeros((maxbt, 2), dtype=int)</span>
    <span class="n">ntr2</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Check which points in the coarser are next to points with unknown travel time and adds them to the binary tree so surounding points can be updated.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isz_2</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">isz_1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">pos_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isx_2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">isx_1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ttn2</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttn1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts2</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">outer_point</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
                <span class="c1">#if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
                <span class="c1">#    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

            <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
            <span class="c1">#fix_val = True</span>
            <span class="c1">#if nsts1[i, j] == 0:</span>
            <span class="c1">#    if i != 0:</span>
            <span class="c1">#        if nsts1[pos_z - 3, pos_x] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if i != nnz1 - 1:</span>
            <span class="c1">#        if nsts1[pos_z + 3, pos_x] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if j != 0:</span>
            <span class="c1">#        if nsts1[pos_z, pos_x - 3] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if j != nnx1 - 1:</span>
            <span class="c1">#        if nsts1[pos_z, pos_x + 3] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if fix_val == True:</span>
            <span class="c1">#        nsts2[pos_z, pos_x] = 0</span>
            <span class="c1">#elif nsts1[i, j] != -1 or fix_val == False:</span>
            <span class="c1">#    nsts2, btg2, ntr2 = addtree(i, j, nsts2, btg2, ntr2, ttn2)</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn2)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn2&quot;)</span>
    <span class="c1">#plt.draw()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(nsts2, vmax=1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;nsts2&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Loop through until boundary encountered.</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">ntr2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">finished</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># if math.sqrt(points) % 1 == 0:</span>
        <span class="c1">#    print(points)</span>
        <span class="c1">#    plt.imshow(ttn)</span>
        <span class="c1">#    plt.draw()</span>
        <span class="c1">#    plt.pause(0.01)</span>
        <span class="c1">#    plt.clf()</span>
        <span class="c1"># plt.close()</span>

        <span class="c1"># We set the &quot;close&quot; point with minimum traveltime to &quot;alive&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex.</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>

        <span class="c1"># Update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># =ix-1:2:ix+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># If far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
                    <span class="c1"># plt.imshow(ttn)</span>
                    <span class="c1"># plt.show()</span>
                <span class="k">elif</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isx_2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># Test points that vary in z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i=iz-1:2:iz+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># Far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="c1"># plt.imshow(ttn)</span>
                    <span class="c1"># plt.show()</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isz_2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#plt.imshow(ttn2)</span>
    <span class="c1">#plt.title(&quot;ttn2&quot;)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Set up variables required for the last finer grid before moving to the original grid.</span>
    <span class="n">size3</span> <span class="o">=</span> <span class="mi">13</span>  <span class="c1"># Size of grid in each direction around source for propagation (total is 2n+1)</span>
    <span class="n">subgrid_size3</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Size of subgrid (must be subgrid_size / 3)</span>
    <span class="n">side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">size3</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx</span> <span class="o">+</span> <span class="n">size3</span><span class="p">)</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">size3</span><span class="p">)</span>
    <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz</span> <span class="o">+</span> <span class="n">size3</span><span class="p">)</span>
    <span class="n">temp_isx</span> <span class="o">=</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">left</span>
    <span class="n">temp_isz</span> <span class="o">=</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">bottom</span>
    <span class="n">veln3</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size3</span><span class="p">)</span>
    <span class="n">velpn3</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">velpn</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size3</span><span class="p">)</span>
    <span class="n">vel_map3</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">vel_map</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size3</span><span class="p">,</span> <span class="n">numba</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1">#if type(stif_den) != type(None):</span>
    <span class="k">if</span> <span class="n">stif_den</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stif_den3</span> <span class="o">=</span> <span class="n">finer_grid_n_2</span><span class="p">(</span><span class="n">stif_den</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stif_den3</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ttn3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln3</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nsts3</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">veln3</span><span class="p">)</span>
    <span class="n">isx_3</span> <span class="o">=</span> <span class="n">subgrid_size3</span> <span class="o">*</span> <span class="n">temp_isx</span>
    <span class="n">isz_3</span> <span class="o">=</span> <span class="n">subgrid_size3</span> <span class="o">*</span> <span class="n">temp_isz</span>
    <span class="n">dnx3</span> <span class="o">=</span> <span class="n">dnx</span> <span class="o">/</span> <span class="n">subgrid_size3</span>
    <span class="n">dnz3</span> <span class="o">=</span> <span class="n">dnz</span> <span class="o">/</span> <span class="n">subgrid_size3</span>
    <span class="n">nnz3</span> <span class="o">=</span> <span class="n">veln3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnx3</span> <span class="o">=</span> <span class="n">veln3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_dist3</span> <span class="o">=</span> <span class="n">subgrid_size3</span> <span class="o">*</span> <span class="n">size3</span>  <span class="c1"># Maximum distance along horiz and vert</span>

    <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="n">veln3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">veln3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">btg3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="c1">#btg3 = np.zeros((maxbt, 2), dtype=int)</span>
    <span class="n">ntr3</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sten_no</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Find the points with surounding points that need updating and add to binary tree.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isz_3</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">isz_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">pos_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isx_3</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">isx_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ttn3</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttn2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts3</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnz2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnx2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">outer_point</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>
                <span class="c1"># if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
                <span class="c1">#    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

            <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn3)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn3&quot;)</span>
    <span class="c1">#plt.draw()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(nsts3, vmax=1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;nsts3&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Update points until we hit a boundary.</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">ntr3</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">finished</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># if math.sqrt(points) % 1 == 0:</span>
        <span class="c1">#    print(points)</span>
        <span class="c1">#    plt.imshow(ttn)</span>
        <span class="c1">#    plt.draw()</span>
        <span class="c1">#    plt.pause(0.01)</span>
        <span class="c1">#    plt.clf()</span>
        <span class="c1"># plt.close()</span>

        <span class="c1"># Set the &quot;close&quot; point with minimum traveltime to &quot;alive&quot;.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts3</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span><span class="p">,</span> <span class="n">ttn3</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>

        <span class="c1"># Now update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># =ix-1:2:ix+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="n">ttn3</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>
                    <span class="c1"># plt.imshow(ttn)</span>
                    <span class="c1"># plt.show()</span>
                <span class="k">elif</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="n">ttn3</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isx_3</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># Test points that vary in z.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i=iz-1:2:iz+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># Far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="n">ttn3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="c1"># plt.imshow(ttn)</span>
                    <span class="c1"># plt.show()</span>
                    <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ntr3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># if no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">dnx3</span><span class="p">,</span> <span class="n">nnx3</span><span class="p">,</span> <span class="n">nnz3</span><span class="p">,</span> <span class="n">veln3</span><span class="p">,</span> <span class="n">velpn3</span><span class="p">,</span> <span class="n">vel_map3</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den3</span><span class="p">)</span>
                    <span class="n">ttn3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts3</span><span class="p">,</span> <span class="n">btg3</span><span class="p">,</span> <span class="n">ttn3</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isz_3</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn3)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn3&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1">#nsts = - np.ones_like(veln)</span>
    <span class="n">nsts</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Move back onto original grid</span>
    <span class="c1"># Find points which have surrounding points that need updating and add them to the min heap.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isz</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">isz_3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">pos_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isx</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">isx_3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ttn</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttn3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnz3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnx3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">outer_point</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>
                <span class="c1">#if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
                <span class="c1">#    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

            <span class="k">if</span> <span class="n">nsts3</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn&quot;)</span>
    <span class="c1">#plt.draw()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(nsts, vmax=1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;nsts&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Run until binary tree is empty (i.e all points have travel times).</span>
    <span class="k">while</span> <span class="n">ntr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Set the &quot;close&quot; point with minimum traveltime to &quot;alive&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex)</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>

        <span class="c1"># Now update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># =ix-1:2:ix+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># far point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>
                    <span class="c1">#plt.imshow(ttn)</span>
                    <span class="c1">#plt.show()</span>
                <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This happens when a &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                        <span class="c1">#sten_no = -10</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>


        <span class="c1"># Test points that vary in z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i=iz-1:2:iz+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="c1">#plt.imshow(ttn)</span>
                    <span class="c1">#plt.show()</span>
                    <span class="c1">#ttn = fouds18(i, ix, nsts, ttn, dnx, dnz, nnx, nnz, veln, velpn, avlist2)</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated.</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>


    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn&quot;)</span>
    <span class="c1">#plt.draw()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.contourf(ttn, 30)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="k">return</span> <span class="n">ttn</span></div>


<div class="viewcode-block" id="travel_finer_grid"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.travel_finer_grid">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">travel_finer_grid</span><span class="p">(</span><span class="n">scx</span><span class="p">,</span> <span class="n">scz</span><span class="p">,</span> <span class="n">veln0</span><span class="p">,</span> <span class="n">velpn0</span><span class="p">,</span> <span class="n">vel_map0</span><span class="p">,</span> <span class="n">stif_den0</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for calculating a travel time field for a given source on a finer grid.</span>

<span class="sd">    :param scx: x position of the source (gets rounded to the nearest grid point in this implementation).</span>
<span class="sd">    :type scx: float</span>
<span class="sd">    :param scz: z position of the source (gets rounded to the nearest grid point in this implementation).</span>
<span class="sd">    :type scz: float</span>
<span class="sd">    :param veln0: Anisotropic orientation of all grid points on the original grid (not finer grid).</span>
<span class="sd">    :type veln0: 2D numpy array</span>
<span class="sd">    :param velpn0: Material index of all grid points on the original grid (not finer grid). Values are 0 if using stiffness tensors and density, otherwise index for column in avlist2.</span>
<span class="sd">    :type velpn0: 2D numpy array of type int</span>
<span class="sd">    :param vel_map0: Value used for scaling velocities at all grid points on the original grid (not finer grid). This is mainly used for isotropic materials.</span>
<span class="sd">    :type vel_map0: 2D numpy array</span>
<span class="sd">    :param stif_den0: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den0: 3D numpy array of type int64</span>
<span class="sd">    :param subgrid_size: The size increase of the finer grid. Must be an odd integer so that points match in the original and finer grid.</span>
<span class="sd">    :type subgrid_size: int</span>
<span class="sd">    :param avlist2: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type avlist2: 2D numpy array</span>
<span class="sd">    :param phase_vel: Phase velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type phase_vel: 2D numpy array</span>
<span class="sd">    :param gox: x position of the point with indices (0, 0).</span>
<span class="sd">    :type gox: float</span>
<span class="sd">    :param goz: z position of the point with indices (0, 0).</span>
<span class="sd">    :type goz: float</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param dnz: Distance between points in the grid in the z direction. Must equal dnx.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :return: Travel time field for the required source on the finer grid.</span>
<span class="sd">    :rtype: 2D numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Generate the finer grid and assign material properties.</span>
    <span class="n">veln</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">veln0</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">)</span>
    <span class="n">velpn</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">velpn0</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">)</span>
    <span class="n">vel_map</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">vel_map0</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">numba</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stif_den0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stif_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="c1">#stif_den = np.zeros((veln.shape[0], veln.shape[1], 5), dtype=np.int64)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stif_den</span> <span class="o">=</span> <span class="n">finer_grid_n_2</span><span class="p">(</span><span class="n">stif_den0</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">)</span>

    <span class="c1">#nnx = veln.shape[1]</span>
    <span class="c1">#nnz = veln.shape[0]</span>
    <span class="p">[</span><span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">]</span> <span class="o">=</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Find the nearest grid point from the source on the original grid and find the corresponding location on he finer grid.</span>
    <span class="n">isx0</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">scx</span> <span class="o">-</span> <span class="n">gox</span><span class="p">)</span> <span class="o">/</span> <span class="n">dnx</span><span class="p">)</span>  <span class="c1"># round((scx-gox)/dnx)+1</span>
    <span class="n">isz0</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">scz</span> <span class="o">-</span> <span class="n">goz</span><span class="p">)</span> <span class="o">/</span> <span class="n">dnz</span><span class="p">)</span>  <span class="c1"># round((scz-goz)/dnz)+1</span>

    <span class="n">isx</span> <span class="o">=</span> <span class="n">subgrid_size</span> <span class="o">*</span> <span class="n">isx0</span>
    <span class="n">isz</span> <span class="o">=</span> <span class="n">subgrid_size</span> <span class="o">*</span> <span class="n">isz0</span>
    <span class="c1">#print(isx0, isz0, veln0.shape)</span>
    <span class="c1">#print(isx, isz, nnx, nnz)</span>

    <span class="c1"># Set up min heap variables.</span>
    <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="n">nnx</span> <span class="o">*</span> <span class="n">nnz</span><span class="p">)</span>
    <span class="n">ntr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ttn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1">#btg = np.zeros((maxbt, 2), dtype=int)</span>
    <span class="n">btg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>


    <span class="c1"># Set up finer grid around the source.</span>
    <span class="n">size1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subgrid_size</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Size of grid around source for initial propagation</span>
    <span class="n">subgrid_size1</span> <span class="o">=</span> <span class="mi">9</span>  <span class="c1"># Size of subgrid for initial propagation</span>
    <span class="n">side1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx</span> <span class="o">+</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz</span> <span class="o">+</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">temp_isx</span> <span class="o">=</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">left</span>
    <span class="n">temp_isz</span> <span class="o">=</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">bottom</span>
    <span class="n">temp_veln</span> <span class="o">=</span> <span class="n">veln</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">temp_velpn</span> <span class="o">=</span> <span class="n">velpn</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">temp_vel_map</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>


    <span class="n">veln1</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">temp_veln</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">)</span>
    <span class="n">velpn1</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">temp_velpn</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">)</span>
    <span class="n">vel_map1</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">temp_vel_map</span><span class="p">,</span> <span class="n">subgrid_size1</span><span class="p">,</span> <span class="n">numba</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1">#if type(stif_den) != type(None):</span>
    <span class="k">if</span> <span class="n">stif_den</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stif_den1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(stif_den)</span>
        <span class="c1">#temp_stif_den = stif_den[bottom:top + 1, left:right + 1]</span>
        <span class="n">stif_den1</span> <span class="o">=</span> <span class="n">finer_grid_n_2</span><span class="p">(</span><span class="n">stif_den</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size1</span><span class="p">)</span>
        <span class="c1">#stif_den1 = finer_grid_n_2(stif_den, subgrid_size1)</span>
    <span class="n">ttn1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nsts1</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">veln1</span><span class="p">)</span>
    <span class="n">isx_1</span> <span class="o">=</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="n">temp_isx</span>
    <span class="n">isz_1</span> <span class="o">=</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="n">temp_isz</span>
    <span class="n">dnx1</span> <span class="o">=</span> <span class="n">dnx</span> <span class="o">/</span> <span class="n">subgrid_size1</span>
    <span class="n">nnz1</span> <span class="o">=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnx1</span> <span class="o">=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_dist1</span> <span class="o">=</span> <span class="n">subgrid_size1</span> <span class="o">*</span> <span class="n">size1</span>  <span class="c1"># Maximum distance along horiz and vert</span>

    <span class="c1"># For points which obtained their material properties from the source point, we find their travel time using a straight ray from the source as this region is homogenious.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">side1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">side1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">diff_z</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">if</span> <span class="n">diff_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="c1">#diff_z == 0:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#angle = math.degrees(math.atan(diff_x / diff_z))</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">diff_z</span> <span class="o">/</span> <span class="n">diff_x</span><span class="p">))</span>
                    <span class="n">eff_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">+</span> <span class="n">angle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
                    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">)</span>
                        <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
                        <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_angle</span> <span class="o">-</span> <span class="n">angle1</span>
                        <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">avlist2</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Solve the christoffel equation for the group velocity.</span>
                        <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">eff_angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_angle</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">))</span>
                            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
                            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">tan_ang</span><span class="p">)</span>
                            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
                            <span class="k">if</span> <span class="n">eff_angle</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
                            <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">isz</span><span class="p">,</span> <span class="n">isx</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="n">dnx1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_z</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">isz_1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">velocity</span>
                    <span class="c1"># Change node status to 0, so travel times will not be updated.</span>
                    <span class="n">nsts1</span><span class="p">[</span><span class="n">isz_1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Set up min heap for fine grid around the source.</span>
    <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">veln1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#btg1 = np.zeros((maxbt, 2), dtype=int)</span>
    <span class="n">btg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ntr1</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Points with travel times which are next to a point without a travel time are added to the min heap so that surrounding points can obtain travel times.</span>
    <span class="k">if</span> <span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span> <span class="o">&lt;=</span> <span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span> <span class="o">&lt;=</span> <span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">-</span> <span class="n">side1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isx_1</span> <span class="o">+</span> <span class="n">side1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>

    <span class="c1"># Update/Find travel times until we reach the boundary of the starting grid.</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">ntr1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">finished</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># if math.sqrt(points) % 1 == 0:</span>
        <span class="c1">#    print(points)</span>
        <span class="c1">#    plt.imshow(ttn)</span>
        <span class="c1">#    plt.draw()</span>
        <span class="c1">#    plt.pause(0.01)</span>
        <span class="c1">#    plt.clf()</span>
        <span class="c1"># plt.close()</span>

        <span class="c1"># Set the &quot;close&quot; point with minimum traveltime to &quot;alive&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex).</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>

        <span class="c1"># Update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isx_1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># Test points that vary in z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ntr1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">dnx1</span><span class="p">,</span> <span class="n">nnx1</span><span class="p">,</span> <span class="n">nnz1</span><span class="p">,</span> <span class="n">veln1</span><span class="p">,</span> <span class="n">velpn1</span><span class="p">,</span> <span class="n">vel_map1</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den1</span><span class="p">)</span>
                    <span class="n">ttn1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts1</span><span class="p">,</span> <span class="n">btg1</span><span class="p">,</span> <span class="n">ttn1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isz_1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>


    <span class="c1">#plt.imshow(ttn1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn1&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Set up variables for coarser grid.</span>
    <span class="n">size2</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">subgrid_size</span> <span class="c1">#size2 = 6  # Size of grid in each direction around source for propagation (total is 2n+1)</span>
    <span class="n">subgrid_size2</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Size of subgrid (must be subgrid_size / 3)</span>
    <span class="n">side2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">subgrid_size2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isx</span> <span class="o">+</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isz</span> <span class="o">+</span> <span class="n">size2</span><span class="p">)</span>
    <span class="n">temp_isx</span> <span class="o">=</span> <span class="n">isx</span> <span class="o">-</span> <span class="n">left</span>
    <span class="n">temp_isz</span> <span class="o">=</span> <span class="n">isz</span> <span class="o">-</span> <span class="n">bottom</span>
    <span class="n">veln2</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">)</span>
    <span class="n">velpn2</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">velpn</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">)</span>
    <span class="n">vel_map2</span> <span class="o">=</span> <span class="n">finer_grid_n</span><span class="p">(</span><span class="n">vel_map</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">,</span> <span class="n">numba</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stif_den</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stif_den2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stif_den2</span> <span class="o">=</span> <span class="n">finer_grid_n_2</span><span class="p">(</span><span class="n">stif_den</span><span class="p">[</span><span class="n">bottom</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">subgrid_size2</span><span class="p">)</span>

    <span class="n">ttn2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nsts2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">veln2</span><span class="p">)</span>
    <span class="n">isx_2</span> <span class="o">=</span> <span class="n">subgrid_size2</span> <span class="o">*</span> <span class="n">temp_isx</span>
    <span class="n">isz_2</span> <span class="o">=</span> <span class="n">subgrid_size2</span> <span class="o">*</span> <span class="n">temp_isz</span>
    <span class="n">dnx2</span> <span class="o">=</span> <span class="n">dnx</span> <span class="o">/</span> <span class="n">subgrid_size2</span>
    <span class="n">nnz2</span> <span class="o">=</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnx2</span> <span class="o">=</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_dist2</span> <span class="o">=</span> <span class="n">subgrid_size2</span> <span class="o">*</span> <span class="n">size2</span>  <span class="c1"># Maximum distance along horiz and vert</span>

    <span class="c1"># Set up min heap.</span>
    <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">veln2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#btg2 = np.zeros((maxbt, 2), dtype=int)</span>
    <span class="n">btg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numba</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ntr2</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Add points with travel times to the coarser grid and check if the point is next to a points with no travel time.</span>
    <span class="c1"># If it is we add the point to the binary tree so neighbouring point can get travel time estimates.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isz_2</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">isz_1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">pos_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isx_2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">isx_1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ttn2</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttn1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts2</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnz1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">outer_point</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
                <span class="c1">#if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
                <span class="c1">#    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

            <span class="k">if</span> <span class="n">nsts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
            <span class="c1">#fix_val = True</span>
            <span class="c1">#if nsts1[i, j] == 0:</span>
            <span class="c1">#    if i != 0:</span>
            <span class="c1">#        if nsts1[pos_z - 3, pos_x] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if i != nnz1 - 1:</span>
            <span class="c1">#        if nsts1[pos_z + 3, pos_x] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if j != 0:</span>
            <span class="c1">#        if nsts1[pos_z, pos_x - 3] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if j != nnx1 - 1:</span>
            <span class="c1">#        if nsts1[pos_z, pos_x + 3] == -1:</span>
            <span class="c1">#            fix_val = False</span>
            <span class="c1">#    if fix_val == True:</span>
            <span class="c1">#        nsts2[pos_z, pos_x] = 0</span>
            <span class="c1">#elif nsts1[i, j] != -1 or fix_val == False:</span>
            <span class="c1">#    nsts2, btg2, ntr2 = addtree(i, j, nsts2, btg2, ntr2, ttn2)</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn2)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn2&quot;)</span>
    <span class="c1">#plt.draw()</span>
    <span class="c1">#plt.show()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(nsts2, vmax=1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;nsts2&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Update/Find travel time estimates until we reach the edge of the grid.</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">ntr2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">finished</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># Set the &quot;close&quot; point with minimum traveltime to &quot;alive&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>

        <span class="c1"># Now update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isx_2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># Test points that vary in z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i=iz-1:2:iz+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ntr2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">dnx2</span><span class="p">,</span> <span class="n">nnx2</span><span class="p">,</span> <span class="n">nnz2</span><span class="p">,</span> <span class="n">veln2</span><span class="p">,</span> <span class="n">velpn2</span><span class="p">,</span> <span class="n">vel_map2</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den2</span><span class="p">)</span>
                    <span class="n">ttn2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts2</span><span class="p">,</span> <span class="n">btg2</span><span class="p">,</span> <span class="n">ttn2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">isz_2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_dist2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">finished</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#plt.imshow(ttn2)</span>
    <span class="c1">#plt.title(&quot;ttn2&quot;)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.show()</span>


    <span class="c1"># Unused since a finer grid was already applied at the begining.</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    size3 = 13  # Size of grid in each direction around source for propagation (total is 2n+1)</span>
<span class="sd">    subgrid_size3 = 3  # Size of subgrid (must be subgrid_size / 3)</span>
<span class="sd">    side = int((subgrid_size3 - 1) / 2)</span>
<span class="sd">    left = max(0, isx - size3)</span>
<span class="sd">    right = min(nnx - 1, isx + size3)</span>
<span class="sd">    bottom = max(0, isz - size3)</span>
<span class="sd">    top = min(nnz - 1, isz + size3)</span>
<span class="sd">    temp_isx = isx - left</span>
<span class="sd">    temp_isz = isz - bottom</span>
<span class="sd">    veln3 = finer_grid_n(veln[bottom:top+1, left:right+1], subgrid_size3)</span>
<span class="sd">    velpn3 = finer_grid_n(velpn[bottom:top+1, left:right+1], subgrid_size3)</span>
<span class="sd">    vel_map3 = finer_grid_n(vel_map[bottom:top + 1, left:right + 1], subgrid_size3, numba.float32)</span>
<span class="sd">    if type(stif_den) != type(None):</span>
<span class="sd">        stif_den3 = finer_grid_n_2(stif_den[bottom:top + 1, left:right + 1], subgrid_size3)</span>
<span class="sd">    else:</span>
<span class="sd">        stif_den3 = None</span>
<span class="sd">    ttn3 = np.zeros(veln3.shape)</span>
<span class="sd">    nsts3 = - np.ones_like(veln3)</span>
<span class="sd">    isx_3 = subgrid_size3 * temp_isx</span>
<span class="sd">    isz_3 = subgrid_size3 * temp_isz</span>
<span class="sd">    dnx3 = dnx / subgrid_size3</span>
<span class="sd">    dnz3 = dnz / subgrid_size3</span>
<span class="sd">    nnz3 = veln3.shape[0]</span>
<span class="sd">    nnx3 = veln3.shape[1]</span>
<span class="sd">    max_dist3 = subgrid_size3 * size3  # Maximum distance along horiz and vert</span>

<span class="sd">    snb = 0.5</span>
<span class="sd">    maxbt = round(snb * veln3.shape[0] * veln3.shape[1])</span>
<span class="sd">    # btg = np.zeros((maxbt, 2), dtype=numba.int32)</span>
<span class="sd">    btg3 = np.zeros((maxbt, 2), dtype=int)</span>
<span class="sd">    ntr3 = 0</span>
<span class="sd">    sten_no = 0</span>

<span class="sd">    for i in range(0, ttn2.shape[0] + 1, 3):</span>
<span class="sd">        for j in range(0, ttn2.shape[1] + 1, 3):</span>
<span class="sd">            pos_z = int(isz_3 + (i - isz_2) / 3)</span>
<span class="sd">            pos_x = int(isx_3 + (j - isx_2) / 3)</span>
<span class="sd">            ttn3[pos_z, pos_x] = ttn2[i, j]</span>
<span class="sd">            if nsts2[i, j] == 0:</span>
<span class="sd">                nsts3[pos_z, pos_x] = 0</span>
<span class="sd">                outer_point = False</span>
<span class="sd">                if i - 3 &gt;= 0:</span>
<span class="sd">                    if nsts2[i - 3, j] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if i + 3 &lt;= nnz2 - 1:</span>
<span class="sd">                    if nsts2[i + 3, j] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if j - 3 &gt;= 0:</span>
<span class="sd">                    if nsts2[i, j - 3] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if j + 3 &lt;= nnx2 - 1:</span>
<span class="sd">                    if nsts2[i, j + 3] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if outer_point == True:</span>
<span class="sd">                    nsts3, btg3, ntr3 = addtree(pos_z, pos_x, nsts3, btg3, ntr3, ttn3)</span>
<span class="sd">                # if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
<span class="sd">                #    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

<span class="sd">            if nsts2[i, j] &gt; 0:</span>
<span class="sd">                nsts3, btg3, ntr3 = addtree(pos_z, pos_x, nsts3, btg3, ntr3, ttn3)</span>

<span class="sd">    #plt.figure(figsize=(8, 8))</span>
<span class="sd">    #plt.imshow(ttn3)</span>
<span class="sd">    #plt.gca().invert_yaxis()</span>
<span class="sd">    #plt.title(&quot;ttn3&quot;)</span>
<span class="sd">    #plt.draw()</span>

<span class="sd">    #plt.figure(figsize=(8, 8))</span>
<span class="sd">    #plt.imshow(nsts3, vmax=1)</span>
<span class="sd">    #plt.gca().invert_yaxis()</span>
<span class="sd">    #plt.title(&quot;nsts3&quot;)</span>
<span class="sd">    #plt.show()</span>

<span class="sd">    finished = False</span>
<span class="sd">    while ntr3 &gt; 0 and finished == False:</span>
<span class="sd">        # if math.sqrt(points) % 1 == 0:</span>
<span class="sd">        #    print(points)</span>
<span class="sd">        #    plt.imshow(ttn)</span>
<span class="sd">        #    plt.draw()</span>
<span class="sd">        #    plt.pause(0.01)</span>
<span class="sd">        #    plt.clf()</span>
<span class="sd">        # plt.close()</span>
<span class="sd">        # ! Set the &quot;close&quot; point with minimum traveltime</span>
<span class="sd">        # ! to &quot;alive&quot;</span>
<span class="sd">        # !</span>
<span class="sd">        ix = btg3[1, 1]  # [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and</span>
<span class="sd">        # child nodes more complex</span>
<span class="sd">        iz = btg3[1, 0]</span>
<span class="sd">        nsts3[iz, ix] = 0</span>
<span class="sd">        # ! Update the binary tree by removing the root and</span>
<span class="sd">        # ! sweeping down the tree.</span>
<span class="sd">        # !</span>
<span class="sd">        nsts3, btg3, ntr3, ttn3 = downtree(nsts3, btg3, ntr3, ttn3)</span>

<span class="sd">        # ! Now update or find values of up to four grid points</span>
<span class="sd">        # ! that surround the new &quot;alive&quot; point.</span>
<span class="sd">        # !</span>
<span class="sd">        # ! Test points that vary in x</span>
<span class="sd">        # !</span>
<span class="sd">        for i in [ix - 1, ix + 1]:  # =ix-1:2:ix+1</span>
<span class="sd">            if 0 &lt;= i &lt;= nnx3 - 1:</span>
<span class="sd">                if nsts3[iz, i] == -1:</span>
<span class="sd">                    # ! This option occurs when a far point is added to the list of &quot;close&quot; points</span>
<span class="sd">                    new_TT = update(veln3, velpn3, vel_map3, nsts3, ttn3, iz, i, dnx3, nnz3, nnx3, phase_vel, stif_den3)</span>
<span class="sd">                    # if new_TT == -1.0:</span>
<span class="sd">                    #    new_TT = fouds18_TT</span>
<span class="sd">                    if new_TT == -1.0:  # or new_TT &lt; fouds18_TT:</span>
<span class="sd">                        new_TT = fouds18_A(iz, i, nsts3, ttn3, dnx3, dnx3, nnx3, nnz3, veln3, velpn3, vel_map3, avlist2, stif_den3)</span>
<span class="sd">                    ttn3[iz, i] = new_TT</span>
<span class="sd">                    # ttn = fouds18(iz, i, nsts, ttn, dnx, dnz, nnx, nnz, veln, velpn, avlist2)</span>
<span class="sd">                    nsts3, btg3, ntr3 = addtree(iz, i, nsts3, btg3, ntr3, ttn3)</span>
<span class="sd">                    # plt.imshow(ttn)</span>
<span class="sd">                    # plt.show()</span>
<span class="sd">                elif nsts3[iz, i] &gt; 0:</span>
<span class="sd">                    # !</span>
<span class="sd">                    # ! This happens when a &quot;close&quot; point is updated</span>
<span class="sd">                    # !</span>
<span class="sd">                    new_TT = update(veln3, velpn3, vel_map3, nsts3, ttn3, iz, i, dnx3, nnz3, nnx3, phase_vel, stif_den3)</span>
<span class="sd">                    # if new_TT == -1.0:</span>
<span class="sd">                    #    new_TT = fouds18_TT</span>
<span class="sd">                    if new_TT == -1.0:  # or new_TT &lt; fouds18_TT:</span>
<span class="sd">                        new_TT = fouds18_A(iz, i, nsts3, ttn3, dnx3, dnx3, nnx3, nnz3, veln3, velpn3, vel_map3, avlist2, stif_den3)</span>
<span class="sd">                    ttn3[iz, i] = new_TT</span>
<span class="sd">                    # ttn = fouds18(iz, i, nsts, ttn, dnx, dnz, nnx, nnz, veln, velpn, avlist2)</span>
<span class="sd">                    nsts3, btg3 = updtree(iz, i, nsts3, btg3, ttn3)</span>
<span class="sd">            elif abs(isx_3 - i) == max_dist3 + 1:</span>
<span class="sd">                finished = True</span>

<span class="sd">        # !</span>
<span class="sd">        # ! Test points that vary in z</span>
<span class="sd">        # !</span>
<span class="sd">        for i in [iz - 1, iz + 1]:  # i=iz-1:2:iz+1</span>
<span class="sd">            if 0 &lt;= i &lt;= nnz3 - 1:</span>
<span class="sd">                if nsts3[i, ix] == -1:</span>
<span class="sd">                    # ! This option occurs when a far point is added to the list of &quot;close&quot; points           % !</span>
<span class="sd">                    new_TT = update(veln3, velpn3, vel_map3, nsts3, ttn3, i, ix, dnx3, nnz3, nnx3, phase_vel, stif_den3)</span>
<span class="sd">                    if new_TT == -1.0:  # or new_TT &lt; fouds18_TT:</span>
<span class="sd">                        new_TT = fouds18_A(i, ix, nsts3, ttn3, dnx3, dnx3, nnx3, nnz3, veln3, velpn3, vel_map3, avlist2, stif_den3)</span>
<span class="sd">                    ttn3[i, ix] = new_TT</span>
<span class="sd">                    # plt.imshow(ttn)</span>
<span class="sd">                    # plt.show()</span>
<span class="sd">                    # ttn = fouds18(i, ix, nsts, ttn, dnx, dnz, nnx, nnz, veln, velpn, avlist2)</span>
<span class="sd">                    nsts3, btg3, ntr3 = addtree(i, ix, nsts3, btg3, ntr3, ttn3)</span>
<span class="sd">                elif nsts3[i, ix] &gt; 0:</span>
<span class="sd">                    # !</span>
<span class="sd">                    # ! This happens when a &quot;close&quot; point is updated</span>
<span class="sd">                    # !</span>
<span class="sd">                    new_TT = update(veln3, velpn3, vel_map3, nsts3, ttn3, i, ix, dnx3, nnz3, nnx3, phase_vel, stif_den3)</span>
<span class="sd">                    if new_TT == -1.0:  # or new_TT &lt; fouds18_TT:</span>
<span class="sd">                        new_TT = fouds18_A(i, ix, nsts3, ttn3, dnx3, dnx3, nnx3, nnz3, veln3, velpn3, vel_map3, avlist2, stif_den3)</span>
<span class="sd">                    ttn3[i, ix] = new_TT</span>
<span class="sd">                    # ttn = fouds18(i, ix, nsts, ttn, dnx, dnz, nnx, nnz, veln, velpn, avlist2)</span>
<span class="sd">                    nsts3, btg3 = updtree(i, ix, nsts3, btg3, ttn3)</span>
<span class="sd">            elif abs(isz_3 - i) == max_dist3 + 1:</span>
<span class="sd">                finished = True</span>

<span class="sd">    #plt.figure(figsize=(8, 8))</span>
<span class="sd">    #plt.imshow(ttn3)</span>
<span class="sd">    #plt.gca().invert_yaxis()</span>
<span class="sd">    #plt.title(&quot;ttn3&quot;)</span>
<span class="sd">    #plt.show()</span>

<span class="sd">    nsts = - np.ones(veln.shape, dtype=int)</span>
<span class="sd">    for i in range(0, ttn3.shape[0] + 1, 3):</span>
<span class="sd">        for j in range(0, ttn3.shape[1] + 1, 3):</span>
<span class="sd">            pos_z = int(isz + (i - isz_3) / 3)</span>
<span class="sd">            pos_x = int(isx + (j - isx_3) / 3)</span>
<span class="sd">            ttn[pos_z, pos_x] = ttn3[i, j]</span>
<span class="sd">            if nsts3[i, j] == 0:</span>
<span class="sd">                nsts[pos_z, pos_x] = 0</span>
<span class="sd">                outer_point = False</span>
<span class="sd">                if i - 3 &gt;= 0:</span>
<span class="sd">                    if nsts3[i - 3, j] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if i + 3 &lt;= nnz3 - 1:</span>
<span class="sd">                    if nsts3[i + 3, j] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if j - 3 &gt;= 0:</span>
<span class="sd">                    if nsts3[i, j - 3] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if j + 3 &lt;= nnx3 - 1:</span>
<span class="sd">                    if nsts3[i, j + 3] == -1:</span>
<span class="sd">                        outer_point = True</span>
<span class="sd">                else:</span>
<span class="sd">                    outer_point = True</span>
<span class="sd">                if outer_point == True:</span>
<span class="sd">                    nsts, btg, ntr = addtree(pos_z, pos_x, nsts, btg, ntr, ttn)</span>
<span class="sd">                #if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
<span class="sd">                #    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

<span class="sd">            if nsts3[i, j] &gt; 0:</span>
<span class="sd">                nsts, btg, ntr = addtree(pos_z, pos_x, nsts, btg, ntr, ttn)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Set up variables for the original grid and move points with a travel time in the previous grid that have a corresponding point in the new grid to the new grid.</span>
    <span class="c1"># Check if these points have neighbouring points without a travel time and if they do, add them to the min heap so neighbouring points can be updated.</span>
    <span class="n">nsts</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">veln</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ttn2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">pos_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isz</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">isz_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">pos_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">isx</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">isx_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ttn</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttn2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts</span><span class="p">[</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnz2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">nnx2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outer_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">outer_point</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>
                <span class="c1"># if nsts1[i - 3, j] == -1 or nsts1[i + 3, j] != -1 or nsts1[i, j - 3] == -1 or nsts1[i, j + 3] == -1:</span>
                <span class="c1">#    nsts2, btg2, ntr2 = addtree(pos_z, pos_x, nsts2, btg2, ntr2, ttn2)</span>

            <span class="k">if</span> <span class="n">nsts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">pos_z</span><span class="p">,</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn&quot;)</span>
    <span class="c1">#plt.show()</span>
    <span class="c1">#plt.draw()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(nsts, vmax=1)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;nsts&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="c1"># Update/find travel times until all points in the grid have a travel time.</span>
    <span class="k">while</span> <span class="n">ntr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Set the &quot;close&quot; point with minimum travel time to &quot;alive&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [1,?] as position 1 on binary tree not using 0 index (makes calculating parent and child nodes more complex</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">btg</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Update the binary tree by removing the root and sweeping down the tree.</span>
        <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span> <span class="o">=</span> <span class="n">downtree</span><span class="p">(</span><span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>

        <span class="c1"># Now update or find values of up to four grid points that surround the new &quot;alive&quot; point.</span>
        <span class="c1"># Test points that vary in x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points.</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>
                    <span class="c1">#plt.imshow(ttn)</span>
                    <span class="c1">#plt.show()</span>
                <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated.</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">iz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>


        <span class="c1"># Test points that vary in z.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">iz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i=iz-1:2:iz+1</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># &quot;far&quot; point is added to the list of &quot;close&quot; points</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span> <span class="o">=</span> <span class="n">addtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nsts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># &quot;close&quot; point is updated</span>
                    <span class="n">new_TT</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_TT</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># If no stencil could be used.</span>
                        <span class="n">new_TT</span> <span class="o">=</span> <span class="n">fouds18_A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">avlist2</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
                    <span class="n">ttn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_TT</span>
                    <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span> <span class="o">=</span> <span class="n">updtree</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ttn</span><span class="p">)</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.imshow(ttn)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn&quot;)</span>
    <span class="c1">#plt.show()</span>
    <span class="c1">#plt.draw()</span>

    <span class="c1">#plt.figure(figsize=(8, 8))</span>
    <span class="c1">#plt.contourf(ttn, 30)</span>
    <span class="c1">#plt.gca().invert_yaxis()</span>
    <span class="c1">#plt.title(&quot;ttn&quot;)</span>
    <span class="c1">#plt.show()</span>

    <span class="k">return</span> <span class="n">ttn</span> <span class="o">/</span> <span class="n">subgrid_size</span></div>


<div class="viewcode-block" id="time_between_points"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.time_between_points">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">time_between_points</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the travel time of a straight ray between two points on a finer grid.</span>

<span class="sd">    :param x1: x index of the starting position on the finer grid. Does not need to be an integer value.</span>
<span class="sd">    :type x1: float</span>
<span class="sd">    :param x2: x index of the end position on the finer grid. Does not need to be an integer value.</span>
<span class="sd">    :type x2: float</span>
<span class="sd">    :param y1: y index of the starting position on the finer grid. Does not need to be an integer value.</span>
<span class="sd">    :type y1: float</span>
<span class="sd">    :param y2: y index of the end position on the finer grid. Does not need to be an integer value.</span>
<span class="sd">    :type y2: float</span>
<span class="sd">    :param dnx: Distance between grid points on the original grid.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param subgrid_size: Odd integer for the size that the original grid was increased by to obtain the finer grid.</span>
<span class="sd">    :type subgrid_size: int</span>
<span class="sd">    :param velocity_dat: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type velocity_dat: 2D numpy array</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points on the original grid.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points on the original grid (0 if using stiffness tensors and density, otherwise index for column in velocity_dat).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points on the original grid (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type int64</span>
<span class="sd">    :return: Travel time of straight ray.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find the coordinates on the original grid.</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="n">subgrid_size</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">/</span> <span class="n">subgrid_size</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">/</span> <span class="n">subgrid_size</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">/</span> <span class="n">subgrid_size</span>

    <span class="c1"># Set up variables for keeping track of the position of the ray and total time.</span>
    <span class="n">section_time</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">start_x</span> <span class="o">=</span> <span class="n">x1</span>
    <span class="n">end_x</span> <span class="o">=</span> <span class="n">x2</span>
    <span class="n">start_y</span> <span class="o">=</span> <span class="n">y1</span>
    <span class="n">end_y</span> <span class="o">=</span> <span class="n">y2</span>
    <span class="n">prev_x</span> <span class="o">=</span> <span class="n">x1</span>
    <span class="n">prev_y</span> <span class="o">=</span> <span class="n">y1</span>

    <span class="c1"># Find the direction of the ray.</span>
    <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)))</span>
    <span class="c1">#total_length = dnx * math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) / subgrid_size</span>

    <span class="c1"># Find the equation of the ray path as y=mx+c</span>
    <span class="k">if</span> <span class="n">end_x</span> <span class="o">!=</span> <span class="n">start_x</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_y</span> <span class="o">-</span> <span class="n">start_y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">end_x</span> <span class="o">-</span> <span class="n">start_x</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">start_y</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">start_x</span>
    <span class="n">finished_x</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">finished_y</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># determine if x and y values increase or decrease along the ray path.</span>
    <span class="k">if</span> <span class="n">start_x</span> <span class="o">&lt;</span> <span class="n">end_x</span><span class="p">:</span>
        <span class="n">dir_x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dir_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">start_y</span> <span class="o">&lt;</span> <span class="n">end_y</span><span class="p">:</span>
        <span class="n">dir_y</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dir_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Find the next x and y values where the ray path will intersect the boundary between two points.</span>
    <span class="n">next_x</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">start_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">dir_x</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">next_y</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">start_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="mf">0.5</span>

    <span class="c1"># Go through all cells that the ray path passes and determine the travel time in that section of the ray.</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">finished_x</span> <span class="ow">and</span> <span class="n">finished_y</span><span class="p">):</span>
        <span class="c1"># Determine if the next cell boundary in the x and y directions is after the rnd of the ray.</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">next_x</span> <span class="o">&gt;</span> <span class="n">end_x</span> <span class="ow">and</span> <span class="n">dir_x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">next_x</span> <span class="o">&lt;</span> <span class="n">end_x</span> <span class="ow">and</span> <span class="n">dir_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="ow">and</span> <span class="n">finished_x</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">finished_x</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">next_x</span> <span class="o">=</span> <span class="n">end_x</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">next_y</span> <span class="o">&gt;</span> <span class="n">end_y</span> <span class="ow">and</span> <span class="n">dir_y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">next_y</span> <span class="o">&lt;</span> <span class="n">end_y</span> <span class="ow">and</span> <span class="n">dir_y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="ow">and</span> <span class="n">finished_y</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">finished_y</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">next_y</span> <span class="o">=</span> <span class="n">end_y</span>
        <span class="c1"># Determine coordinates of next points of intersection.</span>
        <span class="k">if</span> <span class="n">end_x</span> <span class="o">==</span> <span class="n">start_x</span><span class="p">:</span>
            <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">start_x</span>
            <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_y</span>
            <span class="n">next_y</span> <span class="o">+=</span> <span class="n">dir_y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_x_yval</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">next_x</span> <span class="o">+</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">next_y_xval</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_y</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start_x</span> <span class="o">-</span> <span class="n">next_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">start_y</span> <span class="o">-</span> <span class="n">next_x_yval</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">start_x</span> <span class="o">-</span> <span class="n">next_y_xval</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">start_y</span> <span class="o">-</span> <span class="n">next_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">next_x</span>
                    <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_x_yval</span>
                    <span class="n">next_x</span> <span class="o">+=</span> <span class="n">dir_x</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">next_y_xval</span>
                    <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_y</span>
                    <span class="n">next_y</span> <span class="o">+=</span> <span class="n">dir_y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">next_x</span>
                <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_x_yval</span>
                <span class="n">next_x</span> <span class="o">+=</span> <span class="n">dir_x</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">prev_x</span> <span class="o">+</span> <span class="n">next_x_val</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">prev_y</span> <span class="o">+</span> <span class="n">next_y_val</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Determine the effective angle of the ray path through the material in the region.</span>
        <span class="n">eff_ang</span> <span class="o">=</span> <span class="p">(</span><span class="n">veln</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">dnx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">prev_x</span> <span class="o">-</span> <span class="n">next_x_val</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">prev_y</span> <span class="o">-</span> <span class="n">next_y_val</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#if x1 != x2:</span>
        <span class="c1">#    distance = total_length * (prev_x - next_x_val)/(x1 - x2)</span>
        <span class="c1">#else:</span>
        <span class="c1">#    distance = total_length * (prev_y - next_y_val)/(y1 - y2)</span>

        <span class="c1"># Determine the velocity of the ray in the section.</span>
        <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">stif_den</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">eff_ang</span> <span class="o">-</span> <span class="n">angle1</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">*</span> <span class="n">velocity_dat</span><span class="p">[</span><span class="n">angle1</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]]</span> <span class="o">+</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">velocity_dat</span><span class="p">[</span><span class="n">angle2</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Solve the christoffel equation for group velocity.</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">eff_ang</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">))</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
                <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
                <span class="k">if</span> <span class="n">eff_ang</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                    <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
                <span class="n">velocity</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">eff_ang</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>

        <span class="c1"># Update the total time with the last section of the ray.</span>
        <span class="n">slown</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">velocity</span>
        <span class="n">section_time</span> <span class="o">+=</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">slown</span>

        <span class="c1"># Move to new section.</span>
        <span class="n">prev_x</span> <span class="o">=</span> <span class="n">next_x_val</span>
        <span class="n">prev_y</span> <span class="o">=</span> <span class="n">next_y_val</span>
    <span class="c1"># print(section_time)</span>
    <span class="c1"># input(&quot;done&quot;)</span>
    <span class="k">return</span> <span class="n">section_time</span></div>


<div class="viewcode-block" id="ray_time"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.ray_time">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ray_time</span><span class="p">(</span><span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the travel time along a ray path by integrating along the path.</span>

<span class="sd">    :param ray_x: x indices of the points in the ray path on the finer grid.</span>
<span class="sd">    :type ray_x: 1D numpy array</span>
<span class="sd">    :param ray_y: y indices of the points in the ray path on the finer grid.</span>
<span class="sd">    :type ray_y: 1D numpy array</span>
<span class="sd">    :param dnx: Distance between points on the original grid.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param subgrid_size: Size that the original grid was increased by to obtain the finer grid (odd integer)</span>
<span class="sd">    :type subgrid_size: int</span>
<span class="sd">    :param velocity_dat: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type velocity_dat: 2D numpy array</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points on the original grid.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points on the original grid (0 if using stiffness tensors and density, otherwise index for column in velocity_dat).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points on the original grid (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: 3D numpy array of type int64 of material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type int64</span>
<span class="sd">    :return: Travel time along ray path</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Loop through all sections of the ray path and sum all the travel times of the sections.</span>
    <span class="n">trav_time</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ray_x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trav_time</span> <span class="o">+=</span> <span class="n">time_between_points</span><span class="p">(</span><span class="n">ray_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ray_y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ray_y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trav_time</span></div>


<div class="viewcode-block" id="travel_times"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.travel_times">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">travel_times</span><span class="p">(</span><span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a ray path up into smaller sections such that we have a point every time we change direction or change between grid cells.</span>

<span class="sd">    :param ray_x: x indices of the points in the ray path.</span>
<span class="sd">    :type ray_x: 1D numpy array</span>
<span class="sd">    :param ray_y: y indices of the points in the ray path.</span>
<span class="sd">    :type ray_y: 1D numpy array</span>
<span class="sd">    :return: ray_x, ray_y - arrays of the x and y indices of ray path which has been split up.</span>
<span class="sd">    :rtype: 2D numpy array, 2D numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ray_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ray_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">ray_y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ray_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="c1"># Go through each section of the ray a split it up into smaller sections.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ray_x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start_x</span> <span class="o">=</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">end_x</span> <span class="o">=</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">start_y</span> <span class="o">=</span> <span class="n">ray_y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">end_y</span> <span class="o">=</span> <span class="n">ray_y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">end_x</span> <span class="o">!=</span> <span class="n">start_x</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_y</span> <span class="o">-</span> <span class="n">start_y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">end_x</span> <span class="o">-</span> <span class="n">start_x</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">start_y</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">start_x</span>
        <span class="n">finished_x</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">finished_y</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">start_x</span> <span class="o">&lt;</span> <span class="n">end_x</span><span class="p">:</span>
            <span class="n">dir_x</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dir_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">start_y</span> <span class="o">&lt;</span> <span class="n">end_y</span><span class="p">:</span>
            <span class="n">dir_y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dir_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Find where the ray path next crosses a boundary in the x and y direction.</span>
        <span class="n">next_x</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">start_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">dir_x</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">next_y</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">start_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">dir_y</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="c1"># Loop through all regions that the ray path crosses.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">finished_x</span> <span class="ow">and</span> <span class="n">finished_y</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">next_x</span> <span class="o">&gt;</span> <span class="n">end_x</span> <span class="ow">and</span> <span class="n">dir_x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">next_x</span> <span class="o">&lt;</span> <span class="n">end_x</span> <span class="ow">and</span> <span class="n">dir_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">finished_x</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">next_x</span> <span class="o">=</span> <span class="n">end_x</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">next_y</span> <span class="o">&gt;</span> <span class="n">end_y</span> <span class="ow">and</span> <span class="n">dir_y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">next_y</span> <span class="o">&lt;</span> <span class="n">end_y</span> <span class="ow">and</span> <span class="n">dir_y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">finished_y</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">next_y</span> <span class="o">=</span> <span class="n">end_y</span>
            <span class="k">if</span> <span class="n">end_x</span> <span class="o">==</span> <span class="n">start_x</span><span class="p">:</span>
                <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">start_x</span>
                <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_y</span>
                <span class="n">next_y</span> <span class="o">+=</span> <span class="n">dir_y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_x_yval</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">next_x</span> <span class="o">+</span> <span class="n">c</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">next_y_xval</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_y</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">start_x</span> <span class="o">-</span> <span class="n">next_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">start_y</span> <span class="o">-</span> <span class="n">next_x_yval</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span>
                            <span class="n">start_x</span> <span class="o">-</span> <span class="n">next_y_xval</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span>
                            <span class="n">start_y</span> <span class="o">-</span> <span class="n">next_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">next_x</span>
                        <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_x_yval</span>
                        <span class="n">next_x</span> <span class="o">+=</span> <span class="n">dir_x</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">next_y_xval</span>
                        <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_y</span>
                        <span class="n">next_y</span> <span class="o">+=</span> <span class="n">dir_y</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_x_val</span> <span class="o">=</span> <span class="n">next_x</span>
                    <span class="n">next_y_val</span> <span class="o">=</span> <span class="n">next_x_yval</span>
                    <span class="n">next_x</span> <span class="o">+=</span> <span class="n">dir_x</span>

            <span class="c1"># Add points onto the ray path.</span>
            <span class="n">ray_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ray_x1</span><span class="p">,</span> <span class="n">next_x_val</span><span class="p">)</span>
            <span class="n">ray_y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ray_y1</span><span class="p">,</span> <span class="n">next_y_val</span><span class="p">)</span>
            <span class="c1"># plt.plot(ray_x, ray_y, &quot;bx&quot;)</span>
            <span class="c1"># plt.plot(ray_x1, ray_y1, &quot;r+&quot;)</span>
            <span class="c1"># plt.grid()</span>
            <span class="c1"># plt.show()</span>
    <span class="k">return</span> <span class="n">ray_x1</span><span class="p">,</span> <span class="n">ray_y1</span></div>


<div class="viewcode-block" id="find_ray"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.find_ray">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find_ray</span><span class="p">(</span><span class="n">dnx</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">rec_TTF</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds a ray path using the travel time field with the receiver as the source. The travel time field is calculated on a finer grid than the original grid.</span>

<span class="sd">    :param dnx: Distance between points on the original grid.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param velocity_dat: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type velocity_dat: 2D numpy array</span>
<span class="sd">    :param source: indices for the coordinates of the source on the original grid i.e [i, j].</span>
<span class="sd">    :type source: array of length 2</span>
<span class="sd">    :param receiver: indices of the coordinates of the receiver on the original grid.</span>
<span class="sd">    :type receiver: array of length 2</span>
<span class="sd">    :param rec_TTF: Travel time field with the receiver as the source on the finer grid.</span>
<span class="sd">    :type rec_TTF: 2D numpy array</span>
<span class="sd">    :param veln: 2D numpy array for the anisotropic orientation of all grid points on the original grid.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points on the original grid(0 if using stiffness tensors and density, otherwise index for column in velocity_dat).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points on the original grid (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type int64</span>
<span class="sd">    :param subgrid_size: The size increase from the original grid to the finer grid.</span>
<span class="sd">    :type subgrid_size: int</span>
<span class="sd">    :return: ray_x, ray_y, travel_time - Arrays for the x and y indices of the points on the ray path and the travel time along the ray.</span>
<span class="sd">    :rtype: 1D numpy array, 1D numpy array, float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parameter for distance along plane for center.</span>
    <span class="n">plane_dist</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">search_dist</span> <span class="o">=</span> <span class="n">plane_dist</span> <span class="o">*</span> <span class="n">subgrid_size</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1">#search_dist_2 = plane_dist * subgrid_size - int((subgrid_size - 1) / 2)</span>
    <span class="n">search_dist_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">plane_dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">subgrid_size</span> <span class="o">+</span> <span class="mi">1</span>


    <span class="c1"># Set up arrays for storing the ray path.</span>
    <span class="n">ray_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># number of points in ray undetermined so setting a max length</span>
    <span class="n">ray_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ray_x</span><span class="p">)</span>
    <span class="n">ray_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ray_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">last_x</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_y</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ray_len</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Set the last section of the ray to the vector from source to reciever to get an initial direction to determine the plane to use for ray tracing.</span>
    <span class="n">last_vect_x</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_vect_y</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nnx</span> <span class="o">=</span> <span class="n">rec_TTF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnz</span> <span class="o">=</span> <span class="n">rec_TTF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Add points to the ray path untill we are sufficiently close to the reciever to use a stright ray to the reciever (end of the ray).</span>
    <span class="c1"># We choose 1.6 arbitrarily so that we do not go past the reciever and the distance between the last two points is not too large.</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">last_x</span> <span class="o">-</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">last_y</span> <span class="o">-</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.6</span> <span class="o">*</span> <span class="n">subgrid_size</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Ensures ray goes to receiver when close.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">last_x</span> <span class="o">-</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">last_y</span> <span class="o">-</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">subgrid_size</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">last_vect_x</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_x</span>
            <span class="n">last_vect_y</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_y</span>
        <span class="c1"># computes max value of absolute value of dot product between last section of the ray path and unit vectors of [1,0],[1,1],[0,1] and [1,-1] to determine which plane to use in ray tracing.</span>
        <span class="c1"># Absolute value is used to account for two directions at once (vector rotated 180deg as well).</span>
        <span class="n">dir_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">last_vect_x</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">last_vect_x</span> <span class="o">+</span> <span class="n">last_vect_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">last_vect_y</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">last_vect_x</span> <span class="o">-</span> <span class="n">last_vect_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]))</span>
        <span class="k">if</span> <span class="n">dir_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Plane is in the form x = c so we find the c value of the closest point (integer values ensure the plane passes through points in the grid.</span>
            <span class="n">c_value</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span>
            <span class="c1"># Determine which of the two directions should be used</span>
            <span class="k">if</span> <span class="n">last_vect_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># plane is to the right of the last point in the ray</span>
                <span class="n">c_value</span> <span class="o">+=</span> <span class="n">subgrid_size</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># moving to left</span>
                <span class="n">c_value</span> <span class="o">-=</span> <span class="n">subgrid_size</span>
            <span class="k">if</span> <span class="n">c_value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c_value</span> <span class="o">&gt;=</span> <span class="n">nnz</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1">#if 0 &lt; round(last_x) &lt; nnx - 1:</span>
            <span class="c1">#    if rec_TTF[round(last_y), round(last_x) - 1] &gt; rec_TTF[round(last_y), round(last_x) + 1]:</span>
            <span class="c1">#        c_value += subgrid_size</span>
            <span class="c1">#    else:  # moving to left</span>
            <span class="c1">#        c_value -= subgrid_size</span>
            <span class="c1">#elif round(last_x) == 0:</span>
            <span class="c1">#    c_value += subgrid_size</span>
            <span class="c1">#else:</span>
            <span class="c1">#    c_value -= subgrid_size</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">search_dist</span><span class="p">)</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">search_dist</span><span class="p">)</span>
            <span class="n">TT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Find the fastest time from the last point in the ray to the receiver when the ray must go through a point in the plane</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)):</span>
                <span class="n">x_val</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">min_val</span>
                <span class="n">TT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec_TTF</span><span class="p">[</span><span class="n">x_val</span><span class="p">,</span> <span class="n">c_value</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_between_points</span><span class="p">(</span><span class="n">last_x</span><span class="p">,</span> <span class="n">c_value</span><span class="p">,</span> <span class="n">last_y</span><span class="p">,</span> <span class="n">x_val</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>

            <span class="c1"># If there are no local minimums then the minimum over the interval is either at the beginning or the end.</span>
            <span class="k">if</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># Look for a local minimum over all possible sets of three successive points.</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">time1</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">time2</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">time3</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">time1</span> <span class="o">&gt;=</span> <span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">time3</span><span class="p">:</span>
                    <span class="c1"># If there is a local minimum between the points fit a quadratic equation to the three points and use it to predict the location and value of the local minimum</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">time1</span> <span class="o">+</span> <span class="n">time3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">time2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># quadratic using x_values of -1,0 and 1 (increasing x values by j returns values back to correct position).</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">time3</span> <span class="o">-</span> <span class="n">time1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="o">-</span> <span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">position</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">position</span> <span class="o">+</span> <span class="n">c</span>
                        <span class="n">position</span> <span class="o">+=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="c1"># For finding the global minimum from the local minimums</span>
                    <span class="k">if</span> <span class="n">local_min_val</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
                        <span class="n">min_i</span> <span class="o">=</span> <span class="n">position</span>
                        <span class="n">minimum</span> <span class="o">=</span> <span class="n">local_min_val</span>
            <span class="c1"># Add new point to the ray path (length is incremented at the end of the loop).</span>
            <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_value</span>
            <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_i</span> <span class="o">+</span> <span class="n">min_val</span>
        <span class="k">elif</span> <span class="n">dir_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Plane is in the form y = -x+c so we find the c value of the closest point (integer values ensure the plane passes through points in the grid.</span>
            <span class="n">c_value</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span>
            <span class="c1"># Determine which of the two directions we want to use.</span>
            <span class="k">if</span> <span class="n">last_vect_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># moving up right</span>
                <span class="n">c_value</span> <span class="o">+=</span> <span class="n">subgrid_size</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_value</span> <span class="o">-</span> <span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">search_dist_2</span><span class="p">)</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c_value</span><span class="p">,</span> <span class="n">c_value</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">search_dist_2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># moving down left</span>
                <span class="n">c_value</span> <span class="o">-=</span> <span class="n">subgrid_size</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_value</span> <span class="o">-</span> <span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">c_value</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">search_dist_2</span><span class="p">)</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c_value</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">search_dist_2</span><span class="p">)</span>
            <span class="c1">#if (0 &lt; round(last_x) &lt; nnx - 1) and (0 &lt; round(last_y) &lt; nnz - 1):</span>
            <span class="c1">#    if rec_TTF[round(last_y) - 1, round(last_x) - 1] &gt; rec_TTF[round(last_y) + 1, round(last_x) + 1]:</span>
            <span class="c1">#        c_value += subgrid_size</span>
            <span class="c1">#    else:  # moving down left</span>
            <span class="c1">#        c_value -= subgrid_size</span>
            <span class="c1">#elif round(last_x) == 0 or round(last_y) == nnz - 1:</span>
            <span class="c1">#    c_value -= subgrid_size</span>
            <span class="c1">#else:</span>
            <span class="c1">#    c_value += subgrid_size</span>
            <span class="c1"># Determine which values of x are valid.</span>
            <span class="c1">#min_x = max(0, c_value - (nnx - 1))</span>
            <span class="c1">#max_x = min(nnz - 1, c_value)</span>
            <span class="n">TT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Find the fastest time from the last point in the ray to the receiver when the ray must go through a point in the plane</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)):</span>
                <span class="n">x_coord</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">y_coord</span> <span class="o">=</span> <span class="o">-</span> <span class="n">x_coord</span> <span class="o">+</span> <span class="n">c_value</span>
                <span class="c1">#TT[i] = rec_TTF[x_coord, y_coord] + time_between_points(last_x, x_coord, last_y, y_coord, dnx, subgrid_size, velocity_dat, veln, velpn, vel_map, stif_den)</span>
                <span class="n">TT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec_TTF</span><span class="p">[</span><span class="n">y_coord</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_between_points</span><span class="p">(</span><span class="n">last_x</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">,</span> <span class="n">last_y</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>

            <span class="c1"># If no local minimum is found then the minimum over the the interval is either at the beginning or the end.</span>
            <span class="k">if</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># We check all possible sets of the consecutive points for a local minimum.</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">time1</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">time2</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">time3</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">time1</span> <span class="o">&gt;=</span> <span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">time3</span><span class="p">:</span>
                    <span class="c1"># If there is a local minimum between the points fit a quadratic equation to the three points and use it to predict the location and value of the local minimum</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">time1</span> <span class="o">+</span> <span class="n">time3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">time2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># quadratic using x_values of -1,0 and 1 (increasing position value by j returns values back to correct position).</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">time3</span> <span class="o">-</span> <span class="n">time1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="o">-</span> <span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">position</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">position</span> <span class="o">+</span> <span class="n">c</span>
                        <span class="n">position</span> <span class="o">+=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="c1"># For finding global minimum</span>
                    <span class="k">if</span> <span class="n">local_min_val</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
                        <span class="n">min_i</span> <span class="o">=</span> <span class="n">position</span>
                        <span class="n">minimum</span> <span class="o">=</span> <span class="n">local_min_val</span>
            <span class="c1"># Add new point to the ray path (length is incremented at the end of the loop).</span>

            <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">min_i</span>
            <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_value</span> <span class="o">-</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">dir_index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Plane is in the form y = c so we find the c value of the closest point (integer values ensure the plane passes through points in the grid.</span>
            <span class="n">c_value</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span>
            <span class="c1"># Check which of the two directions we want to use.</span>
            <span class="k">if</span> <span class="n">last_vect_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># moving up</span>
                <span class="n">c_value</span> <span class="o">+=</span> <span class="n">subgrid_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_value</span> <span class="o">-=</span> <span class="n">subgrid_size</span>
            <span class="k">if</span> <span class="n">c_value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c_value</span> <span class="o">&gt;=</span> <span class="n">nnx</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1">#if 0 &lt; round(last_y) &lt; nnz - 1:</span>
            <span class="c1">#    if rec_TTF[round(last_y) - 1, round(last_x)] &gt; rec_TTF[round(last_y) + 1, round(last_x)]:</span>
            <span class="c1">#        c_value += subgrid_size</span>
            <span class="c1">#    else:</span>
            <span class="c1">#        c_value -= subgrid_size</span>
            <span class="c1">#elif round(last_y) == 0:</span>
            <span class="c1">#    c_value += subgrid_size</span>
            <span class="c1">#else:</span>
            <span class="c1">#    c_value -= subgrid_size</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">search_dist</span><span class="p">)</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">search_dist</span><span class="p">)</span>

            <span class="n">TT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Find the fastest time from the last point in the ray to the receiver when the ray must go through a point in the plane.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)):</span>
                <span class="n">y_val</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">min_val</span>
                <span class="n">TT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec_TTF</span><span class="p">[</span><span class="n">c_value</span><span class="p">,</span> <span class="n">y_val</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_between_points</span><span class="p">(</span><span class="n">last_x</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">last_y</span><span class="p">,</span> <span class="n">c_value</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
            <span class="c1"># If no local minimum is found then the minimum over the the interval is either at the beginning or the end.</span>
            <span class="k">if</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># We check all possible sets of the consecutive points for a local minimum.</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">time1</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">time2</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">time3</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">time1</span> <span class="o">&gt;=</span> <span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">time3</span><span class="p">:</span>
                    <span class="c1"># If there is a local minimum between the points fit a quadratic equation to the three points and use it to predict the location and value of the local minimum.</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">time1</span> <span class="o">+</span> <span class="n">time3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">time2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># quadratic using x_values of -1,0 and 1 (increasing position value by j returns values back to correct position).</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">time3</span> <span class="o">-</span> <span class="n">time1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="o">-</span> <span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">position</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">position</span> <span class="o">+</span> <span class="n">c</span>
                        <span class="n">position</span> <span class="o">+=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="k">if</span> <span class="n">local_min_val</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
                        <span class="n">min_i</span> <span class="o">=</span> <span class="n">position</span>
                        <span class="n">minimum</span> <span class="o">=</span> <span class="n">local_min_val</span>
            <span class="c1"># Add new point to the ray path (length is incremented at the end of the loop).</span>
            <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_i</span> <span class="o">+</span> <span class="n">min_val</span>
            <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Plane is in the form y = x+c so we find the c value of the closest point (integer values ensure the plane passes through points in the grid.</span>
            <span class="n">c_value</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span>
            <span class="c1"># Determine which of the two directions to use.</span>
            <span class="k">if</span> <span class="n">last_vect_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># moving up left</span>
                <span class="n">c_value</span> <span class="o">+=</span> <span class="n">subgrid_size</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="n">c_value</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_value</span> <span class="o">-</span> <span class="n">search_dist_2</span><span class="p">)</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_value</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">search_dist_2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># moving down right</span>
                <span class="n">c_value</span> <span class="o">-=</span> <span class="n">subgrid_size</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="n">c_value</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">search_dist_2</span><span class="p">)</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">nnz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">nnx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_value</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_value</span> <span class="o">+</span> <span class="n">search_dist_2</span><span class="p">)</span>
            <span class="c1">#if (subgrid_size &lt; round(last_x) &lt; nnx - 1 - subgrid_size) and (0 &lt; round(last_y) &lt; nnz - 1):</span>
            <span class="c1">#    print(rec_TTF[round(last_y) - subgrid_size, round(last_x) + subgrid_size], rec_TTF[round(last_y) + subgrid_size, round(last_x) - subgrid_size])</span>
            <span class="c1">#    if rec_TTF[round(last_y) - subgrid_size, round(last_x) + subgrid_size] &lt; rec_TTF[round(last_y) + subgrid_size, round(last_x) - subgrid_size]:</span>
            <span class="c1">#        c_value += subgrid_size</span>
            <span class="c1">#    else:  # moving down right</span>
            <span class="c1">#        c_value -= subgrid_size</span>
            <span class="c1">#elif round(last_x) &lt; subgrid_size and round(last_y) &lt; subgrid_size:</span>
            <span class="c1">#    c_value += subgrid_size</span>
            <span class="c1">#else:</span>
            <span class="c1">#    c_value -= subgrid_size</span>
            <span class="c1"># Determine which values of x are in the grid.</span>
            <span class="c1">#min_x = max(0, - c_value)</span>
            <span class="c1">#max_x = min((nnz - 1), (nnx - 1) - c_value)</span>
            <span class="n">TT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Find the fastest time from the last point in the ray to the receiver when the ray must go through a point in the plane.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)):</span>
                <span class="n">x_coord</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">y_coord</span> <span class="o">=</span> <span class="n">x_coord</span> <span class="o">+</span> <span class="n">c_value</span>
                <span class="n">TT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec_TTF</span><span class="p">[</span><span class="n">y_coord</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">]</span> <span class="o">+</span> <span class="n">time_between_points</span><span class="p">(</span><span class="n">last_x</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">,</span> <span class="n">last_y</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
            <span class="c1"># If no local minimum is found then the minimum over the the interval is either at the beginning or the end.</span>
            <span class="k">if</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">min_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># We check all possible sets of the consecutive points for a local minimum.</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">time1</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">time2</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">time3</span> <span class="o">=</span> <span class="n">TT</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">time1</span> <span class="o">&gt;=</span> <span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">time3</span><span class="p">:</span>
                    <span class="c1"># If there is a local minimum between the points fit a quadratic equation to the three points and use it to predict the location and value of the local minimum</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">time1</span> <span class="o">+</span> <span class="n">time3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">time2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># quadratic using x_values of -1,0 and 1 (increasing position value by j returns values back to correct position).</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">time3</span> <span class="o">-</span> <span class="n">time1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">time2</span>

                    <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="o">-</span> <span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">position</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">position</span> <span class="o">+</span> <span class="n">c</span>
                        <span class="n">position</span> <span class="o">+=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">position</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">local_min_val</span> <span class="o">=</span> <span class="n">time2</span>
                    <span class="k">if</span> <span class="n">local_min_val</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
                        <span class="n">min_i</span> <span class="o">=</span> <span class="n">position</span>
                        <span class="n">minimum</span> <span class="o">=</span> <span class="n">local_min_val</span>
            <span class="c1"># Add new point to the ray path (length is incremented at the end of the loop).</span>
            <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">min_i</span>
            <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">+</span> <span class="n">c_value</span>
        <span class="c1"># Update the vector for the last section of the ray and update the position of the latest point in the ray path.</span>
        <span class="k">if</span> <span class="n">rec_TTF</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">last_y</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">last_x</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">rec_TTF</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">])]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Travel time to receiver increasing: Finishing ray early&quot;</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            plt.imshow(veln, interpolation=&quot;nearest&quot;, cmap=&quot;hsv&quot;, vmin=0, vmax=90)</span>
<span class="sd">            plt.plot(source[0] / subgrid_size, source[1] / subgrid_size, &quot;x&quot;, color=&quot;orange&quot;)</span>
<span class="sd">            plt.plot(receiver[0] / subgrid_size, receiver[1] / subgrid_size, &quot;+&quot;, color=&quot;orange&quot;)</span>
<span class="sd">            plt.plot(ray_x[0:ray_len + 1] / subgrid_size, ray_y[0:ray_len + 1] / subgrid_size, &quot;k&quot;)</span>
<span class="sd">            plt.plot(ray_x[0:ray_len + 1] / subgrid_size, ray_y[0:ray_len + 1] / subgrid_size, &quot;kx&quot;, markersize=1)</span>
<span class="sd">            plt.show()</span>
<span class="sd">            plt.contourf(rec_TTF, 100, cmap=&quot;flag&quot;)</span>
<span class="sd">            plt.imshow(veln, interpolation=&quot;nearest&quot;, cmap=&quot;hsv&quot;, vmin=0, vmax=90)</span>
<span class="sd">            plt.plot(source[0] / subgrid_size, source[1] / subgrid_size, &quot;x&quot;, color=&quot;orange&quot;)</span>
<span class="sd">            plt.plot(receiver[0] / subgrid_size, receiver[1] / subgrid_size, &quot;+&quot;, color=&quot;orange&quot;)</span>
<span class="sd">            plt.plot(ray_x[0:ray_len + 1] / subgrid_size, ray_y[0:ray_len + 1] / subgrid_size, &quot;k&quot;)</span>
<span class="sd">            plt.plot(ray_x[0:ray_len + 1] / subgrid_size, ray_y[0:ray_len + 1] / subgrid_size, &quot;kx&quot;, markersize=1)</span>
<span class="sd">            plt.show()</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">break</span>
        <span class="n">last_vect_x</span> <span class="o">=</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_x</span>
        <span class="n">last_x</span> <span class="o">=</span> <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span>
        <span class="n">last_vect_y</span> <span class="o">=</span> <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_y</span>
        <span class="n">last_y</span> <span class="o">=</span> <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span>
        <span class="n">ray_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#if True: #ray_len &gt; len(ray_x) - 2:</span>
            <span class="c1">#plt.contourf(rec_TTF, 100, cmap=&quot;flag&quot;)</span>
            <span class="c1">#plt.show()</span>
            <span class="c1">#plt.imshow(veln)</span>
            <span class="c1">#plt.plot(ray_x[0:ray_len] / 9, ray_y[0:ray_len] / 9)</span>
            <span class="c1">#plt.plot(ray_x[0:ray_len] / 9, ray_y[0:ray_len] / 9, &quot;kx&quot;)</span>
            <span class="c1">#plt.plot(ray_x[ray_len - 2:ray_len] / 9, ray_y[ray_len - 2:ray_len] / 9, &quot;r&quot;)</span>
            <span class="c1">#plt.plot(source[0] / 9, source[1] / 9, &quot;rx&quot;)</span>
            <span class="c1">#plt.plot(receiver[0] / 9, receiver[1] / 9, &quot;gx&quot;)</span>
            <span class="c1">#plt.plot(ray_x / 9, ray_y / 9, &quot;kx&quot;)</span>
            <span class="c1">#plt.show()</span>
        <span class="c1">#plt.figure(figsize=(6, 6))</span>
        <span class="c1">#print(dir_index)</span>
        <span class="c1">#plt.imshow(veln)</span>
        <span class="c1">#plt.imshow(vel_map)</span>
        <span class="c1">#plt.gca().invert_yaxis()</span>
        <span class="c1">#plt.plot(ray_x[0:ray_len]/subgrid_size, ray_y[0:ray_len]/subgrid_size)</span>
        <span class="c1">#plt.plot(ray_x[ray_len - 1]/subgrid_size, ray_y[ray_len - 1]/subgrid_size, &quot;bx&quot;)</span>
        <span class="c1">#plt.plot([source[0] / subgrid_size, receiver[0] / subgrid_size], [source[1] / subgrid_size, receiver[1] / subgrid_size], &quot;rx&quot;)</span>
        <span class="c1">#plt.plot([(c_value/subgrid_size), (c_value/subgrid_size)], [0, 200])</span>
        <span class="c1">#plt.pause(0.05)</span>
        <span class="c1">#.cla()</span>
        <span class="c1">#plt.show()</span>

    <span class="c1"># Add the final point to the ray path (receiver) and remove all unused values in the arrays</span>
    <span class="n">ray_x</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ray_y</span><span class="p">[</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ray_x</span> <span class="o">=</span> <span class="n">ray_x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">ray_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">ray_y</span> <span class="o">=</span> <span class="n">ray_y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">ray_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1">#if ray_len &lt; 10:</span>
    <span class="c1">#    print(f&quot;ray_len[{ray_len}]&quot;)</span>
    <span class="c1">#plt.imshow(veln)</span>
    <span class="c1">#plt.plot(ray_x/subgrid_size, ray_y/subgrid_size)</span>
    <span class="c1">#plt.show()</span>
    <span class="c1"># Integrate along the ray path to determine the travel time.</span>
    <span class="n">trav_time</span> <span class="o">=</span> <span class="n">ray_time</span><span class="p">(</span><span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">trav_time</span></div>


<div class="viewcode-block" id="slown_d_slown_stif"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.slown_d_slown_stif">[docs]</a><span class="k">def</span> <span class="nf">slown_d_slown_stif</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">c_22</span><span class="p">,</span> <span class="n">c_23</span><span class="p">,</span> <span class="n">c_33</span><span class="p">,</span> <span class="n">c_44</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">vel_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for returning the first derivative of the group velocity from material properties w.r.t group angle.</span>

<span class="sd">    :param angle: Effective group angle (0-180)</span>
<span class="sd">    :type angle: float</span>
<span class="sd">    :param c_22: Stifness parameter in MPa.</span>
<span class="sd">    :type c_22: int</span>
<span class="sd">    :param c_23: Stifness parameter in MPa.</span>
<span class="sd">    :type c_23: int</span>
<span class="sd">    :param c_33: Stifness parameter in MPa.</span>
<span class="sd">    :type c_33: int</span>
<span class="sd">    :param c_44: Stifness parameter in MPa.</span>
<span class="sd">    :type c_44: int</span>
<span class="sd">    :param sigma: Density in Kg/m^3</span>
<span class="sd">    :type sigma: int</span>
<span class="sd">    :param vel_scale: Velocity scaling parameter</span>
<span class="sd">    :type vel_scale: float</span>
<span class="sd">    :return: Derivative of group velocity</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">group_vel</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">angle</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_33</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_22</span>
            <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_scale</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
            <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_scale</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mi">45</span><span class="p">:</span>
        <span class="n">slown1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">group_vel</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">slown2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">group_vel</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="c1">#return [slown1, (slown1 - slown2) / 0.01]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">slown1</span> <span class="o">-</span> <span class="n">slown2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.01</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slown1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">group_vel</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">slown2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">group_vel</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="c1">#return [slown1, (slown1 - slown2) / -0.01]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">slown1</span> <span class="o">-</span> <span class="n">slown2</span><span class="p">)</span> <span class="o">/</span> <span class="o">-</span><span class="mf">0.01</span></div>

<div class="viewcode-block" id="group_vel"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.group_vel">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">group_vel</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">c_22</span><span class="p">,</span> <span class="n">c_23</span><span class="p">,</span> <span class="n">c_33</span><span class="p">,</span> <span class="n">c_44</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">vel_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for the group velocity from material properties w.r.t group angle.</span>

<span class="sd">        :param angle: Effective group angle (0-180)</span>
<span class="sd">        :type angle: float</span>
<span class="sd">        :param c_22: Stifness parameter in MPa.</span>
<span class="sd">        :type c_22: int</span>
<span class="sd">        :param c_23: Stifness parameter in MPa.</span>
<span class="sd">        :type c_23: int</span>
<span class="sd">        :param c_33: Stifness parameter in MPa.</span>
<span class="sd">        :type c_33: int</span>
<span class="sd">        :param c_44: Stifness parameter in MPa.</span>
<span class="sd">        :type c_44: int</span>
<span class="sd">        :param sigma: Density in Kg/m^3</span>
<span class="sd">        :type sigma: int</span>
<span class="sd">        :param vel_scale: Velocity scaling parameter, default is 1.</span>
<span class="sd">        :type vel_scale: float</span>
<span class="sd">        :return: Group velocity</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="o">-</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">angle</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_33</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_22</span>
        <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_scale</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
            <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">vel_scale</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span></div>

<div class="viewcode-block" id="parallel_TTF"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.parallel_TTF">[docs]</a><span class="k">def</span> <span class="nf">parallel_TTF</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used in class for calculating travel time fields in parallel. All variables which remain unchanged for different sources are used to initialise the process.</span>

<span class="sd">    :param queue1: Queue used for receiving jobs to complete from the main process.</span>
<span class="sd">    :type queue1: multiprocessing Queue</span>
<span class="sd">    :param queue2: Queue used for returning completed jobs back to the main process.</span>
<span class="sd">    :type queue2: multiprocessing Queue</span>
<span class="sd">    :param nsts: Node status for points in the array. -1 is for unknown point, if point is still in the heap then value is the position in the tree. Should have values of -1 for start.</span>
<span class="sd">    :type nsts: 2D numpy array of type int</span>
<span class="sd">    :param btg: Positions of points in the min heap.</span>
<span class="sd">    :type btg: 2D numpy array of type int</span>
<span class="sd">    :param ntr: Number of points in binary tree. Should start with 0.</span>
<span class="sd">    :type ntr: int</span>
<span class="sd">    :param ttn: Current travel time at all points in the grid (0 for far points).</span>
<span class="sd">    :type ttn: 2D numpy array</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points (0 if using stiffness tensors and density, otherwise index for column in velocity_dat.</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density). Stiffness tensors must be in MPa to avoid overflow errors.</span>
<span class="sd">    :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">    :param velocity_dat: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type velocity_dat: 2D numpy array</span>
<span class="sd">    :param phase_vel: Phase velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type phase_vel: 2D numpy array</span>
<span class="sd">    :param gox: x position of the point with indices (0, 0).</span>
<span class="sd">    :type gox: float</span>
<span class="sd">    :param goz: z position of the point with indices (0, 0).</span>
<span class="sd">    :type goz: float</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param dnz: Distance between points in the grid in the z direction. Must equal dnx.</span>
<span class="sd">    :type dnz: float</span>
<span class="sd">    :param nnx: Number of points in the grid in the x direction.</span>
<span class="sd">    :type nnx: int</span>
<span class="sd">    :param nnz: Number of points in the grid in the z direction.</span>
<span class="sd">    :type nnz: int</span>
<span class="sd">    :param low_mem: Parameter used when there are issues with insufficient memory. If True then saves travel time fields to the current directory as &quot;temp_TTF_i.npy&quot; for source index i.</span>
<span class="sd">    :type low_mem: bool</span>
<span class="sd">    :return: Does not return anything. Process should be terminated by main process when finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Run forever until terminated</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Obtain the index of the source and the x and z position of the source. If there is no values in the queue will wait until one is available or the process is terminated.</span>
        <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">low_mem</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># If low_mem is False then the index of the source and the travel time field is send back to the main process (index of the source is required so the main process knows which travel time field has been calculated.</span>
            <span class="n">queue2</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">travel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If low_mem is True then the travel time field is saved to the current directory and the travel time field is returned as None (main process does not expect a travel time field).</span>
            <span class="n">TTF</span> <span class="o">=</span> <span class="n">travel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">nsts</span><span class="p">,</span> <span class="n">btg</span><span class="p">,</span> <span class="n">ntr</span><span class="p">,</span> <span class="n">ttn</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">nnx</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;temp_TTF_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">TTF</span><span class="p">)</span>
            <span class="n">queue2</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span></div>


<div class="viewcode-block" id="parallel_TTF_finer_grid"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.parallel_TTF_finer_grid">[docs]</a><span class="k">def</span> <span class="nf">parallel_TTF_finer_grid</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used in class for calculating travel time fields in parallel. All variables which remain unchanged for different sources are used to initialise the process.</span>

<span class="sd">    :param queue1: Queue used for receiving jobs to complete from the main process.</span>
<span class="sd">    :type queue1: multiprocessing Queue</span>
<span class="sd">    :param queue2: Queue used for returning completed jobs back to the main process.</span>
<span class="sd">    :type queue2: multiprocessing Queue</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points (0 if using stiffness tensors and density, otherwise index for column in velocity_dat).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density).</span>
<span class="sd">    :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">    :param subgrid_size: The size increase of the finer grid. Must be an odd integer so that points match in the original and finer grid.</span>
<span class="sd">    :type subgrid_size: int</span>
<span class="sd">    :param velocity_dat: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type velocity_dat: 2D numpy array</span>
<span class="sd">    :param phase_vel: Phase velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type phase_vel: 2D numpy array</span>
<span class="sd">    :param gox: x position of the point with indices (0, 0).</span>
<span class="sd">    :type gox: float</span>
<span class="sd">    :param goz: z position of the point with indices (0, 0).</span>
<span class="sd">    :type goz: float</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param dnz: Distance between points in the grid in the z direction. Must equal dnx.</span>
<span class="sd">    :type dnz: float</span>
<span class="sd">    :param low_mem: Parameter used when there are issues with insufficient memory. If True then saves travel time fields to the current directory as &quot;temp_TTF_i.npy&quot; for source index i.</span>
<span class="sd">    :type low_mem: bool</span>
<span class="sd">    :return: Does not return anything. Process should be terminated by main process when finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Run forever until terminated</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Obtain the index of the source and the x and z position of the source. If there is no values in the queue will wait until one is available or the process is terminated.</span>
        <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c1">#print(f&quot;starting source {i}\n&quot;, end=&quot;&quot;)</span>
        <span class="k">if</span> <span class="n">low_mem</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># If low_mem is False then the index of the source and the travel time field is send back to the main process (index of the source is required so the main process knows which travel time field has been calculated.</span>
            <span class="n">queue2</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">travel_finer_grid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If low_mem is True then the travel time field is saved to the current directory and the travel time field is returned as None (main process does not expect a travel time field).</span>
            <span class="c1">#try:</span>
            <span class="c1">#    TTF = travel_finer_grid(x, z, veln, velpn, vel_map, stif_den, subgrid_size, velocity_dat, phase_vel, gox, goz, dnx, dnz)</span>
            <span class="c1">#    np.save(&quot;temp_TTF_&quot; + str(i) + &quot;.npy&quot;, TTF)</span>
            <span class="c1">#except:</span>
            <span class="c1">#    print(f&quot;TTF with source {i} failed\n&quot;, end=&quot;&quot;)</span>
            <span class="n">TTF</span> <span class="o">=</span> <span class="n">travel_finer_grid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnz</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;temp_TTF_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="n">TTF</span><span class="p">)</span>
            <span class="n">TTF</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">queue2</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span></div>
        <span class="c1">#print(f&quot;finished source {i}\n&quot;, end=&quot;&quot;)</span>


<div class="viewcode-block" id="parallel_TTF_rays"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.parallel_TTF_rays">[docs]</a><span class="k">def</span> <span class="nf">parallel_TTF_rays</span><span class="p">(</span><span class="n">proc_num</span><span class="p">,</span> <span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="n">trans_pairs</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">scx</span><span class="p">,</span> <span class="n">scz</span><span class="p">,</span> <span class="n">new_trans_x</span><span class="p">,</span> <span class="n">new_trans_z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used in class for calculating travel time fields and ray paths in parallel. All variables which remain unchanged for different sources are used to initialise the process. Uses queue2 with return codes for telling main process when a travel time field is completed and for returning ray paths.</span>

<span class="sd">    :param proc_num: Process number.</span>
<span class="sd">    :type proc_num: int</span>
<span class="sd">    :param queue1: Queue used for receiving jobs to complete from the main process.</span>
<span class="sd">    :type queue1: multiprocessing Queue</span>
<span class="sd">    :param queue2: Queue used for telling main process a travel time field has been calculated or for sending ray paths to main process (using return codes 0 for TTF and 1 for ray).</span>
<span class="sd">    :type queue2: multiprocessing Queue</span>
<span class="sd">    :param veln: Anisotropic orientation of all grid points.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of all grid points (0 if using stiffness tensors and density, otherwise index for column in velocity_dat).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Value used for scaling velocities at all grid points (mainly used for isotropic materials).</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Material parameters with first two indices being the i,j coordinates and the third being the index of the material parameter(c_22, c_23, c_33, c_44, density).</span>
<span class="sd">    :type stif_den: 3D numpy array of type int64</span>
<span class="sd">    :param subgrid_size: The size increase of the finer grid. Must be an odd integer so that points match in the original and finer grid.</span>
<span class="sd">    :type subgrid_size: int</span>
<span class="sd">    :param velocity_dat: Group velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type velocity_dat: 2D numpy array</span>
<span class="sd">    :param phase_vel: Phase velocity of materials at different angles (column 0 is angle i.e 0-360 and other columns are velocity for that angle).</span>
<span class="sd">    :type phase_vel: 2D numpy array</span>
<span class="sd">    :param gox: x position of the point with indices (0, 0).</span>
<span class="sd">    :type gox: float</span>
<span class="sd">    :param goz: z position of the point with indices (0, 0).</span>
<span class="sd">    :type goz: float</span>
<span class="sd">    :param dnx: Distance between points in the grid in the x direction.</span>
<span class="sd">    :type dnx: float</span>
<span class="sd">    :param scx: Array for x coordinates for transducers.</span>
<span class="sd">    :type scx: 1D numpy array</span>
<span class="sd">    :param scz: Array for z coordinates for transducers.</span>
<span class="sd">    :type scz: 1D numpy array</span>
<span class="sd">    :param new_trans_x: Array for x coordinates for transducers on finer grid using grid coordinates.</span>
<span class="sd">    :type new_trans_x: 1D numpy array</span>
<span class="sd">    :param new_trans_z: Array for z coordinates for transducers on finer grid using grid coordinates.</span>
<span class="sd">    :type new_trans_z: 1D numpy array</span>
<span class="sd">    :return: Does not return anything. Process should be terminated by main process when finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_trans</span> <span class="o">=</span> <span class="n">trans_pairs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Run forever until terminated</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Obtain the index of the source and the x and z position of the source. If there is no values in the queue will wait until one is available or the process is terminated.</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">receiver</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_trans_x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">new_trans_z</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
        <span class="n">TTF</span> <span class="o">=</span> <span class="n">travel_finer_grid</span><span class="p">(</span><span class="n">scx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">scz</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">phase_vel</span><span class="p">,</span> <span class="n">gox</span><span class="p">,</span> <span class="n">goz</span><span class="p">,</span> <span class="n">dnx</span><span class="p">,</span> <span class="n">dnx</span><span class="p">)</span>
        <span class="c1">#np.save(f&quot;TTF_{j}.npy&quot;, TTF)</span>
        <span class="n">queue2</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">trans_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_trans_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_trans_z</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">find_ray</span><span class="p">(</span><span class="n">dnx</span><span class="p">,</span> <span class="n">velocity_dat</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">TTF</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">)</span>
                <span class="n">ray_x</span> <span class="o">=</span> <span class="n">ray_x</span> <span class="o">/</span> <span class="n">subgrid_size</span>
                <span class="n">ray_y</span> <span class="o">=</span> <span class="n">ray_y</span> <span class="o">/</span> <span class="n">subgrid_size</span>
                <span class="c1">#np.save(f&quot;./target_rays/ray_x_{i}_{j}.npy&quot;, ray_x)</span>
                <span class="c1">#np.save(f&quot;./target_rays/ray_y_{i}_{j}.npy&quot;, ray_y)</span>
                <span class="n">queue2</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">time</span><span class="p">]])</span></div>


<div class="viewcode-block" id="min_max_vel"><a class="viewcode-back" href="../Anis_TTF_functions.html#Anis_TTF_rays.min_max_vel">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">min_max_vel</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">group_vel_table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for determining the min / max velocity in a model to check if model is input correctly.</span>

<span class="sd">    :param veln: Anisotropic material orientations at grid points. Set as array of zero if using isotropic materials.</span>
<span class="sd">    :type veln: 2D numpy array</span>
<span class="sd">    :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">    :type velpn: 2D numpy array of type int</span>
<span class="sd">    :param vel_map: Values used to scaling velocity for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials (using material with velocity curve with velocity of 1) . If unused then an array of ones is used.</span>
<span class="sd">    :type vel_map: 2D numpy array</span>
<span class="sd">    :param stif_den: Stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">    :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">    :param group_vel_table: Group velocity curves with first column giving the angle (0-360 with increments of 1 degree) and other columns group velocities for each material(column is material indecies). If parameter is unused then defalts to velocity curve for isotropic material with velocity of 1(use vel_map to scale curve to set velocities at each point)</span>
<span class="sd">    :type group_vel_table: 2D numpy array</span>
<span class="sd">    :return: min_vel, max_vel. The minimum and maximum velocity in a model</span>
<span class="sd">    :rtype: float, float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">group_vel_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">group_vel_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">group_vel_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">group_vel_max</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_vel_min</span><span class="p">)):</span>
        <span class="n">group_vel_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">group_vel_table</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">group_vel_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">group_vel_table</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="n">min_vel</span> <span class="o">=</span> <span class="n">group_vel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_22</span><span class="p">,</span> <span class="n">c_23</span><span class="p">,</span> <span class="n">c_33</span><span class="p">,</span> <span class="n">c_44</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">max_vel</span> <span class="o">=</span> <span class="n">min_vel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_vel</span> <span class="o">=</span> <span class="n">vel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">group_vel_table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">velpn</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">max_vel</span> <span class="o">=</span> <span class="n">min_vel</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">velpn</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c_22</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">c_23</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">c_33</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">c_44</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">stif_den</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">135</span><span class="p">]:</span>
                    <span class="n">vel</span> <span class="o">=</span> <span class="n">group_vel</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">c_22</span><span class="p">,</span> <span class="n">c_23</span><span class="p">,</span> <span class="n">c_33</span><span class="p">,</span> <span class="n">c_44</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">min_vel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_vel</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
                    <span class="n">max_vel</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_vel</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_vel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_vel</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">group_vel_min</span><span class="p">[</span><span class="n">velpn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
                <span class="n">max_vel</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_vel</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">group_vel_max</span><span class="p">[</span><span class="n">velpn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">min_vel</span><span class="p">,</span> <span class="n">max_vel</span></div>

<div class="viewcode-block" id="ALI_FMM"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM">[docs]</a><span class="k">class</span> <span class="nc">ALI_FMM</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for calculating travel time fields and performing ray tracing through the travel time fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ALI_FMM.__init__"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">scx</span><span class="p">,</span> <span class="n">scz</span><span class="p">,</span> <span class="n">group_vel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phase_vel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stif_den</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dnx</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initialise class</span>

<span class="sd">        :param veln: Anisotropic material orientations at grid points. Set as array of zeros if using isotropic materials.</span>
<span class="sd">        :type veln: 2D numpy array</span>
<span class="sd">        :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :type velpn: 2D numpy array of type int</span>
<span class="sd">        :raises TypeError: Creates error if velpn is not array of integers</span>
<span class="sd">        :param vel_map: Velocity scaling parameters for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials.</span>
<span class="sd">        :type vel_map: 2D numpy array</span>
<span class="sd">        :param scx: numpy array of x coordinates for sources/recievers.</span>
<span class="sd">        :type scx: 1D numpy array</span>
<span class="sd">        :param scz: numpy array of z coordinates for sources/recievers.</span>
<span class="sd">        :type scz: 1D numpy array</span>
<span class="sd">        :param group_vel: Group velocity curves with first column giving the angle (0-360 with increments of 1 degree) and other columns group velocities for each material(column is material indecies). If parameter is unused then defalts to velocity curve for isotropic material with velocity of 1(use vel_map to scale curve to set velocities at each point)</span>
<span class="sd">        :type group_vel: 2D numpy array</span>
<span class="sd">        :param phase_vel: Phase velocity curves with first column giving the angle (0-360 with increments of 1 degree) and other columns phase velocities for each material(column is material indecies). If parameter is unused then defalts to velocity curve for isotropic material with velocity of 1(use vel_map to scale curve to set velocities at each point)</span>
<span class="sd">        :type phase_vel: 2D numpy array</span>
<span class="sd">        :param stif_den: Stifness tensors at each grid point. First two indecies are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">        :raises TypeError: Creates error if stiffness tensors are not the correct type (np.int64). Does not create error if stifness tensors are not being used (None used)</span>
<span class="sd">        :param dnx: Spacing between each point in metres, defalts as 1e-3.</span>
<span class="sd">        :type dnx: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialise all the parameters to the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span> <span class="o">=</span> <span class="n">stif_den</span>  <span class="c1"># All stifness tensors in MPa not Pa, due to 32 bit numbers</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Stifness tensors and density array must have the type np.int64. 32bit integers will not work correctly.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">stif_den</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1e9</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Stifness tensors must be in MPa, due to 64 bit integer limitations when solving the christoffel equation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">group_vel</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span> <span class="o">=</span> <span class="n">group_vel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span> <span class="o">=</span> <span class="n">phase_vel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">veln</span> <span class="o">=</span> <span class="n">veln</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span> <span class="o">=</span> <span class="n">velpn</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">velpn</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;velpn must be a numpy array of integers&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;velpn must be a numpy array of integers&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span> <span class="o">=</span> <span class="n">vel_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span> <span class="o">=</span> <span class="n">dnx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span> <span class="o">=</span> <span class="n">dnx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnx</span> <span class="o">=</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span> <span class="o">=</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ttn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scx</span> <span class="o">=</span> <span class="n">scx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scz</span> <span class="o">=</span> <span class="n">scz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gox</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goz</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scx</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scx</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scx</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">scx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">scz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scx</span><span class="p">)</span>
        <span class="c1">#self.travel_time_field = np.zeros((self.nsrc, self.nnz, self.nnx))</span>

        <span class="c1"># Allocate memory for node status and binary trees</span>
        <span class="n">snb</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxbt</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">snb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">maxbt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Initialise parameters for storing ray paths in a 2D array and the number of points in the ray path (since the ray paths have different lengths a function is used for obtaining the ray paths).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="ALI_FMM.update"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stif_den</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for computing travel time fields from material properties.</span>

<span class="sd">        :param veln: Anisotropic material orientations at grid points. Set as array of zero if using isotropic materials.</span>
<span class="sd">        :type veln: 2D numpy array</span>
<span class="sd">        :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :type velpn: 2D numpy array of type int</span>
<span class="sd">        :param vel_map: Values used to scaling velocity for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials (using material with velocity curve with velocity of 1) . If unused then an array of ones is used.</span>
<span class="sd">        :type vel_map: 2D numpy array</span>
<span class="sd">        :param stif_den: Stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">        :param subgrid_size: Parameter for computing travel time field on finer grid (must be a odd number), multiply indices by subgrid_size to move between indices on original grid. Default value is set to 1 i.e same as original grid.</span>
<span class="sd">        :type subgrid_size: int</span>
<span class="sd">        :param sources: Array of 0&#39;s and 1&#39;s for selecting which sources should be used for calculating travel time fields. If unused all sources will be used.</span>
<span class="sd">        :type sources: 1D numpy array</span>
<span class="sd">        :return: Travel time fields for all sources. If sources parameter used then sources not used return array of zeros.</span>
<span class="sd">        :rtype: 3D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If stifness tensors and density&#39;s are not used then array of zeros are used (will never be used).</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span> <span class="o">=</span> <span class="n">stif_den</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">veln</span> <span class="o">=</span> <span class="n">veln</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span> <span class="o">=</span> <span class="n">velpn</span>
        <span class="c1"># If no velocity scaling is required then scaling defaults to 1 i.e. does not scale.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vel_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span> <span class="o">=</span> <span class="n">vel_map</span>
        <span class="c1"># If no value is input to sources then all travel time fields are calculated.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">subgrid_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Initialise array for storing travel time fields</span>
            <span class="n">travel_time_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">,</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">):</span>  <span class="c1"># for i=1:nsrc  &quot;, ncols=100&quot;</span>
                <span class="k">if</span> <span class="n">sources</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1">#print(i + 1)</span>
                    <span class="c1"># Array index of transmitter</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="c1"># Call a subroutine that works out the first - arrival traveltime field.</span>
                    <span class="n">ttn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">travel_time_field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">travel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">btg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">travel_time_field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">travel_time_field</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_TTF</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">):</span>  <span class="c1"># for i=1:nsrc</span>
                <span class="k">if</span> <span class="n">sources</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1">#print(i + 1)</span>
                    <span class="c1"># Array index of transmitter</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="c1"># Call a subroutine that works out the first - arrival traveltime field.</span>
                    <span class="k">if</span> <span class="n">first_TTF</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1"># First travel time field determines size of array used for storing arrays.</span>
                        <span class="n">temp_ttf</span> <span class="o">=</span> <span class="n">travel_finer_grid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">)</span>
                        <span class="n">travel_time_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">,</span> <span class="n">temp_ttf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_ttf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">travel_time_field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">temp_ttf</span>
                        <span class="n">first_TTF</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">travel_time_field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">travel_finer_grid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">travel_time_field</span></div>

<div class="viewcode-block" id="ALI_FMM.update_parallel"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.update_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">update_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stif_den</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">low_mem</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for computing travel time fields from material properties in parallel. Parallelization is only possible for different travel time fields. Since there is a computational cost to setting up parallelization, this is not recommended for small grids as will likely take longer.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           Use __name__ == &quot;__main__&quot; in order to run in parallel.</span>

<span class="sd">        :param veln: Anisotropic material orientations at grid points. Set as array of zero if using isotropic materials.</span>
<span class="sd">        :type veln: 2D numpy array</span>
<span class="sd">        :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :type velpn: 2D numpy array of type int</span>
<span class="sd">        :param vel_map: Values used to scaling velocity for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials (using material with velocity curve with velocity of 1) . If unused then an array of ones is used.</span>
<span class="sd">        :type vel_map: 2D numpy array</span>
<span class="sd">        :param stif_den: Stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">        :param subgrid_size: Parameter for computing travel time field on finer grid (must be a odd number), multiply indices by subgrid_size to move between indices on original grid. Default value is set to 1 i.e same as original grid.</span>
<span class="sd">        :type subgrid_size: int</span>
<span class="sd">        :param sources: Array of 0&#39;s and 1&#39;s for selecting which sources should be used for calculating travel time fields. If unused all sources will be used.</span>
<span class="sd">        :type sources: 1D numpy array</span>
<span class="sd">        :param n_threads: Number of threads to be used. If n_threads = 1 then use update instead of update parallel.</span>
<span class="sd">        :type n_threads: int</span>
<span class="sd">        :param low_mem: whether to use less memory or not. True saves travel time fields to directory as &quot;temp_TTF_i.npy&quot;(load using np.load) for TTF i and False saves them in memory.</span>
<span class="sd">        :type low_mem: bool</span>
<span class="sd">        :return: Travel time fields for all sources. If sources parameter used then sources not used will return array of zeros. If low_mem=True then returns None.</span>
<span class="sd">        :rtype: 3D numpy array/None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If stifness tensors and density&#39;s are not used then array of zeros are used (will never be used).</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span> <span class="o">=</span> <span class="n">stif_den</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">veln</span> <span class="o">=</span> <span class="n">veln</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span> <span class="o">=</span> <span class="n">velpn</span>
        <span class="c1"># If no velocity scaling is required then scaling defalts to 1 i.e. does not scale.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vel_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span> <span class="o">=</span> <span class="n">vel_map</span>
        <span class="c1"># If sources parameter is  not used then all sources are used.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Initialise queue for sending data between processes.</span>
        <span class="n">queue1</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="n">queue2</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">):</span>  <span class="c1"># for i=1:nsrc</span>
            <span class="k">if</span> <span class="n">sources</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Add all required sources to the queue so processes can retrieve jobs to complete.</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">queue1</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">subgrid_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ttn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># Initialise processes</span>
            <span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_threads</span><span class="p">):</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">parallel_TTF</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">btg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">))</span>
                <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
            <span class="c1"># Start all processes running.</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">low_mem</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Initialise array for storing travel time fields</span>
                <span class="n">travel_time_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">,</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="c1"># Retrieve all travel time fields from processes and add them to array of travel time fields.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sources</span><span class="p">))),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished TTF&#39;s&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">):</span>
                    <span class="c1"># Waits until a travel time field is recieved</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">TTF</span> <span class="o">=</span> <span class="n">queue2</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">travel_time_field</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">TTF</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">travel_time_field</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># Waits until all travel time fields have been calculated</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sources</span><span class="p">))),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished TTF&#39;s&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">):</span>
                    <span class="n">queue2</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="c1"># Tells all processes to terminate</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="c1"># Will wait until all processes have finished terminating</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="c1"># Will remove all processes so memory is released back to os.</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">travel_time_field</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Uses a finer grid</span>

            <span class="c1"># Set up processes</span>
            <span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_threads</span><span class="p">):</span>
                <span class="n">process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">parallel_TTF_finer_grid</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">veln</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velpn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">,</span> <span class="n">low_mem</span><span class="p">))</span>
                <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
                <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">low_mem</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Waits until the first travel time field is retrieved and used to set size of travel time fields.</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">TTF</span> <span class="o">=</span> <span class="n">queue2</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">travel_time_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsrc</span><span class="p">,</span> <span class="n">TTF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TTF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">travel_time_field</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">TTF</span>
                <span class="c1"># As travel time fields are retrieved they are stored into an array of travel time fields.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sources</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished TTF&#39;s&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">):</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">TTF</span> <span class="o">=</span> <span class="n">queue2</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">travel_time_field</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">TTF</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">travel_time_field</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># Waits until all travel time fields are completed.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sources</span><span class="p">))),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished TTF&#39;s&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">):</span>
                    <span class="n">queue2</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="c1"># Tells all processes to terminate</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="c1"># Will wait until all processes have finished terminating</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="c1"># Will remove all processes so memory is released back to os.</span>
            <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">travel_time_field</span></div>

<div class="viewcode-block" id="ALI_FMM.update_i"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.update_i">[docs]</a>    <span class="k">def</span> <span class="nf">update_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_i</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for computing a single travel time field.</span>

<span class="sd">        :param source_i: Index of the source.</span>
<span class="sd">        :type source_i: int</span>
<span class="sd">        :param veln: Anisotropic material orientations at grid points. Set as array of zeros if using isotropic materials.</span>
<span class="sd">        :type veln: 2D numpy array</span>
<span class="sd">        :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :type velpn: 2D numpy array of type int</span>
<span class="sd">        :param vel_map: Values used for scaling velocities at each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials.</span>
<span class="sd">        :type vel_map: 2D numpy array</span>
<span class="sd">        :param stif_den: Stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">        :param subgrid_size: Parameter for computing travel time field on finer grid (must be a odd number), multiply indies by subgrid_size to move between indices on original grid. Default value is set to 1 i.e same as original grid.</span>
<span class="sd">        :type subgrid_size: int</span>
<span class="sd">        :return: Travel time field for the selected source.</span>
<span class="sd">        :rtype: 2D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no velocity scaling is required/</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vel_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">vel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># If stiffness tensors and density is not being used.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">stif_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
        <span class="c1"># Calculate travel time field</span>
        <span class="k">if</span> <span class="n">subgrid_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">[</span><span class="n">source_i</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scz</span><span class="p">[</span><span class="n">source_i</span><span class="p">])</span>
            <span class="c1"># Call a subroutine that works out the first - arrival traveltime field.</span>
            <span class="n">ttn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">travel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">btg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ttn</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">[</span><span class="n">source_i</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scz</span><span class="p">[</span><span class="n">source_i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">travel_finer_grid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnz</span><span class="p">)</span></div>

<div class="viewcode-block" id="ALI_FMM.plot_phase"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.plot_phase">[docs]</a>    <span class="k">def</span> <span class="nf">plot_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material_index</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the phase velocity curve for a material defined by table of velocities.</span>

<span class="sd">        :param material_index: Index of the material being plotted, default value is 1.</span>
<span class="sd">        :type material_index: int</span>
<span class="sd">        :return: Does not return anything.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">[:,</span> <span class="n">material_index</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALI_FMM.plot_group"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.plot_group">[docs]</a>    <span class="k">def</span> <span class="nf">plot_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material_index</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the group velocity curve for a material defined by table of velocities.</span>

<span class="sd">        :param material_index: Index of the material being plotted, default value is 1.</span>
<span class="sd">        :type material_index: int</span>
<span class="sd">        :return: Does not return anything.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">[:,</span> <span class="n">material_index</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="ALI_FMM.generate_group_vel"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.generate_group_vel">[docs]</a>    <span class="k">def</span> <span class="nf">generate_group_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_22</span><span class="p">,</span> <span class="n">c_23</span><span class="p">,</span> <span class="n">c_33</span><span class="p">,</span> <span class="n">c_44</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the group velocity curve, given a materials stiffness tensors and density.</span>

<span class="sd">        :param c_22: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_22: int</span>
<span class="sd">        :param c_23: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_23: int</span>
<span class="sd">        :param c_33: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_33: int</span>
<span class="sd">        :param c_44: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_44: int</span>
<span class="sd">        :param density: Density of the material in Kg/m^3.</span>
<span class="sd">        :type density: int</span>
<span class="sd">        :param plot: True or False value for whether to plot curve or not. Default is True.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: Array of group velocities from 0 to 360 degrees with increments of 1 degree.</span>
<span class="sd">        :rtype: 2D numpy array</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           c_22 = 203.6e9</span>
<span class="sd">           c_23 = 133.5e9</span>
<span class="sd">           c_33 = 203.6e9</span>
<span class="sd">           c_44 = 129.8e9</span>
<span class="sd">           density = 7874</span>

<span class="sd">           ALI_FMM.generate_group_vel(None, c_22, c_23, c_33, c_44, density, True)</span>

<span class="sd">        .. image:: group_vel.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :alt: Alternative text</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">group_vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">361</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">361</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">180</span><span class="p">:</span>
                <span class="c1"># Solves christoffel equation</span>
                <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
                        <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_33</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_22</span>
                    <span class="n">velocity</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tan_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_33</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_ang</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">tan_ang</span><span class="p">)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="n">c_22</span> <span class="o">-</span> <span class="n">c_33</span>
                    <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                        <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">phase_angle_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">((</span><span class="o">-</span><span class="n">B</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">A</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">C</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span> <span class="o">%</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                    <span class="n">lambda_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_22</span> <span class="o">-</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phase_angle_rad</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan_ang</span> <span class="o">+</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
                    <span class="n">velocity</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">phase_angle_rad</span><span class="p">)</span>
                <span class="n">group_vel</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_vel</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_vel</span><span class="p">[</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">180</span><span class="p">]</span>
        <span class="c1"># Plots group velocity curve if required</span>
        <span class="k">if</span> <span class="n">plot</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">),</span> <span class="n">group_vel</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Group Velocity&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">group_vel</span></div>

<div class="viewcode-block" id="ALI_FMM.generate_phase_vel"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.generate_phase_vel">[docs]</a>    <span class="k">def</span> <span class="nf">generate_phase_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_22</span><span class="p">,</span> <span class="n">c_23</span><span class="p">,</span> <span class="n">c_33</span><span class="p">,</span> <span class="n">c_44</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the phase velocity curve, given a materials stiffness tensors and density.</span>

<span class="sd">        :param c_22: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_22: int</span>
<span class="sd">        :param c_23: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_23: int</span>
<span class="sd">        :param c_33: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_33: int</span>
<span class="sd">        :param c_44: Stiffness Tensor in Pa.</span>
<span class="sd">        :type c_44: int</span>
<span class="sd">        :param density: Density of the material in Kg/m^3.</span>
<span class="sd">        :type density: int</span>
<span class="sd">        :param plot: True or False value for whether to plot curve or not. Default is True.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :return: Array of phase velocities from 0 to 360 degrees with increments of 1 degree.</span>
<span class="sd">        :rtype: 2D numpy array</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           c_22 = 203.6e9</span>
<span class="sd">           c_23 = 133.5e9</span>
<span class="sd">           c_33 = 203.6e9</span>
<span class="sd">           c_44 = 129.8e9</span>
<span class="sd">           density = 7874</span>

<span class="sd">           ALI_FMM.generate_phase_vel(None, c_22, c_23, c_33, c_44, density, True)</span>

<span class="sd">        .. image:: phase_vel.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :alt: Alternative text</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase_vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">361</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">361</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">180</span><span class="p">:</span>
                <span class="c1"># Solves christoffel equation</span>
                <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">90</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
                        <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_33</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">c_22</span>
                    <span class="n">velocity</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_val</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cos_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
                    <span class="n">sin_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">cos_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_22</span> <span class="o">+</span> <span class="n">sin_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">cos_ang</span> <span class="o">*</span> <span class="n">sin_ang</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_23</span> <span class="o">+</span> <span class="n">c_44</span><span class="p">)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="n">cos_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_44</span> <span class="o">+</span> <span class="n">sin_ang</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_33</span>
                    <span class="n">velocity</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">A</span> <span class="o">+</span> <span class="n">C</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">A</span> <span class="o">-</span> <span class="n">C</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">B</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">density</span><span class="p">))</span>
                <span class="n">phase_vel</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase_vel</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_vel</span><span class="p">[</span><span class="n">angle</span> <span class="o">-</span> <span class="mi">180</span><span class="p">]</span>
        <span class="c1"># Plots phase velocity curve is required.</span>
        <span class="k">if</span> <span class="n">plot</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">),</span> <span class="n">phase_vel</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Phase Velocity&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">phase_vel</span></div>

<div class="viewcode-block" id="ALI_FMM.add_materials"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.add_materials">[docs]</a>    <span class="k">def</span> <span class="nf">add_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">materials</span><span class="p">,</span> <span class="n">keep_materials</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for adding materials using stiffness tensors and density of materials. Prints the material indices of materials if existing materials are kept.</span>

<span class="sd">        :param materials: Material properties(stiffness tensors and density) for materials. Either array for single material or 2D array for multiple materials.</span>
<span class="sd">        :type materials: 1D array/2D array</span>
<span class="sd">        :param keep_materials: Whether the current materials in the class are kept when adding materials or deleted.</span>
<span class="sd">        :type keep_materials: bool</span>
<span class="sd">        :return: Nothing is returned. Materials are added into class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">keep_materials</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">materials</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">group_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span>
                <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="n">group_vel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_group_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">phase_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span>
                <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="n">group_vel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_phase_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;material id of new material is &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span>
                <span class="n">phase_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_group_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_phase_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;material id&#39;s of new materials are &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">materials</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">group_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">phase_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">phase_vel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">361</span><span class="p">,</span> <span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">)</span>
            <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">materials</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_group_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_phase_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">materials</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">group_vel_data</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_group_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="n">phase_vel_data</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_phase_vel</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">materials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Saves group and phase velocities into the class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span> <span class="o">=</span> <span class="n">group_vel_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span> <span class="o">=</span> <span class="n">phase_vel_data</span></div>

<div class="viewcode-block" id="ALI_FMM.find_all_TTF_rays"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.find_all_TTF_rays">[docs]</a>    <span class="k">def</span> <span class="nf">find_all_TTF_rays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">trans_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stif_den</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_rays</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes travel time fields for required receivers and performs ray tracing between source and receiver pairs. Returns travel times, however ray paths can be obtained using the function ray_path.</span>

<span class="sd">        :param veln: Anisotropic material orientations at grid points. Set as array of zeros if using isotropic materials.</span>
<span class="sd">        :type veln: 2D numpy array</span>
<span class="sd">        :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :type velpn: 2D numpy array of type int</span>
<span class="sd">        :param vel_map: Velocity scaling parameters for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials. If unused then an array of ones is used.</span>
<span class="sd">        :type vel_map: 2D numpy array</span>
<span class="sd">        :param subgrid_size: Parameter for computing travel time field on finer grid (must be a odd number), multiply indices by subgrid_size to move between indices on original grid. Default value is set to 1 i.e same as original grid.</span>
<span class="sd">        :type subgrid_size: int</span>
<span class="sd">        :param trans_pairs: Transducer pairs where ray tracing is being performed (0 - No ray, 1 - compute ray). If parameter not used then all rays calculated(only one ray calculated per transducer pair i.e transducer is either source or receiver).</span>
<span class="sd">        :type trans_pairs: 2D numpy array</span>
<span class="sd">        :param stif_den: Stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :type stif_den: 3D numpy array of type int64</span>
<span class="sd">        :return: Travel times along the ray paths. When the path is not calculated the value is 0.</span>
<span class="sd">        :rtype: 2D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If no velocity scaling is required.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vel_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">vel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># If stiffness tensors and density&#39;s are not used</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">stif_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">n_trans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isx</span><span class="p">)</span>
        <span class="c1"># Sets up arrays for storing ray paths.</span>
        <span class="k">if</span> <span class="n">save_rays</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># If the ray paths that are required are not included then all combinations of transducers are used (each pair only uses one ray path i.e. transducer in each pair is either source or reciever.</span>
            <span class="n">trans_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">trans_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Determine which travel time fields are required (if not required then travel time field is not calculated).</span>
        <span class="n">rec_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_trans</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rec_trans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Calculate travel time fields.</span>
        <span class="c1">#TTFs = self.update(veln, velpn, vel_map, stif_den, subgrid_size, rec_trans)</span>
        <span class="c1">#print(&quot;Finished TTF&#39;s&quot;)</span>
        <span class="c1">#np.save(&quot;temp_TTFs.npy&quot;, TTFs)</span>
        <span class="c1">#TTFs = np.load(&quot;temp_TTFs.npy&quot;)</span>
        <span class="c1">#for i in range(n_trans):</span>
        <span class="c1">#    plt.contourf(TTFs[i, :, :], 20)</span>
        <span class="c1">#    plt.show()</span>
        <span class="c1">#plt.contour(TTFs[58, :, :], 100)</span>
        <span class="c1">#plt.show()</span>


        <span class="c1"># Calculate position of transducers on finer grid</span>
        <span class="n">new_trans_x</span> <span class="o">=</span> <span class="n">subgrid_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">isx</span>
        <span class="n">new_trans_y</span> <span class="o">=</span> <span class="n">subgrid_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">isz</span>
        <span class="c1">#print(self.isx, self.isz)</span>
        <span class="c1">#print(new_trans_x, new_trans_y)</span>

        <span class="c1"># Create array for storing travel times of ray paths.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">trans_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">))</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">))</span>

        <span class="n">n_rays</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">))</span>
        <span class="c1">#pbar1 = tqdm(total=int(np.sum(rec_trans)), disable=tqdm_disable, ncols=100, desc=&quot;Finished TTF&#39;s&quot;, colour=&quot;green&quot;, bar_format=&quot;{l_bar} {bar} | {n_fmt}/{total_fmt} [{elapsed}]&quot;)</span>
        <span class="c1">#pbar2 = tqdm(total=n_rays, disable=tqdm_disable, ncols=100, desc=&quot;Finished ray paths&quot;, colour=&quot;green&quot;, bar_format=&quot;{l_bar} {bar} | {n_fmt}/{total_fmt} [{elapsed}]&quot;)  # , leave=False)</span>

        <span class="n">pbar1</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rec_trans</span><span class="p">)),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished TTF&#39;s&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">pbar2</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">n_rays</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished ray paths&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">)</span>  <span class="c1"># , leave=False)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(f&quot;Starting TTF [{j}]&quot;)</span>
                <span class="c1">#tqdm.write(f&quot;Starting TTF [{j}]&quot;)</span>
                <span class="n">TTF_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_i</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">)</span>
                <span class="c1">#print(f&quot;Finished TTF [{j}]&quot;)</span>
                <span class="c1">#tqdm.write(f&quot;Finished TTF [{j}]&quot;)</span>
                <span class="n">pbar1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span> <span class="c1">#for j in range(i + 1, len(self.isx)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">trans_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># If the ray path needs to be calculated.</span>
                            <span class="n">source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_trans_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_trans_y</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                            <span class="n">receiver</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_trans_x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">new_trans_y</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                            <span class="c1">#print(f&quot;Starting Ray [{i},{j}]&quot;)</span>
                            <span class="c1">#tqdm.write(f&quot;Starting Ray [{i},{j}]&quot;)</span>
                            <span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_ray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">TTF_j</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">)</span>
                            <span class="c1">#print(f&quot;Finished Ray [{i},{j}]&quot;)</span>
                            <span class="c1">#tqdm.write(f&quot;Finished Ray [{i},{j}]&quot;)</span>
                            <span class="n">pbar2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                            <span class="c1"># Bring ray paths back from finer grid to the original grid.</span>
                            <span class="n">ray_x</span> <span class="o">=</span> <span class="n">ray_x</span> <span class="o">/</span> <span class="n">subgrid_size</span>
                            <span class="n">ray_y</span> <span class="o">=</span> <span class="n">ray_y</span> <span class="o">/</span> <span class="n">subgrid_size</span>

                            <span class="c1"># Store ray path into class to be retrieved using class function ray_path</span>
                            <span class="k">if</span> <span class="n">save_rays</span><span class="p">:</span>
                                <span class="n">ray_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ray_x</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_y</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_len</span>
        <span class="k">return</span> <span class="n">times</span></div>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    def find_all_TTF_rays_parallel(self, veln, velpn, vel_map=None, subgrid_size=9, trans_pairs=None, stif_den=None, n_threads_TTF=2, n_threads_rays=2, low_mem=False, save_rays=True):</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        Computes travel time fields for required receivers and performs ray tracing between source and receiver pairs using parallelisation. Returns travel times, however ray paths can be obtained using the function ray_path.</span>

<span class="sd">        :param veln: 2D numpy array of Anisotropic material orientations at grid points. Set as an array of zeros if using isotropic materials.</span>
<span class="sd">        :param velpn: 2D numpy array of type int for the material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :param vel_map: 2D numpy array of scaling parameters for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials. If unused then a array of ones is used.</span>
<span class="sd">        :param subgrid_size: Parameter for computing travel time field on finer grid (must be a odd number), multiply indices by subgrid_size to move between indices on original grid. Default value is set to 1 i.e same as original grid.</span>
<span class="sd">        :param trans_pairs: 2D numpy array of the transducer pairs where ray tracing is being performed (0 - No ray, 1 - compute ray). If parameter not used then all rays calculated(only one ray calculated per transducer pair i.e transducer is either source or receiver). Leading diagonal must have zeros.</span>
<span class="sd">        :param stif_den: 3D numpy array of type int64 for stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :param n_threads_TTF: Number of threads to be used for calculating travel time fields.</span>
<span class="sd">        :param n_threads_rays: Number of threads to be used for calculating travel time fields.</span>
<span class="sd">        :param low_mem: Boolean value to reduce ram usage. False will return the travel time fields and True will save to the directory as &quot;temp_TTF_i.npy&quot; for index i. Can be loaded using TTF = np.load(&quot;temp_TTF_i.npy&quot;). If True then the number of threads must be greater than 1 (Only saves memory for lots of sources).</span>
<span class="sd">        :return: 2D numpy array of travel times along the ray paths. When the path is not calculated the value is 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="sd">        min_vel, max_vel = min_max_vel(veln, velpn, vel_map, stif_den, self.velocity_dat)</span>
<span class="sd">        if min_vel &lt; 1000:</span>
<span class="sd">            Warning(f&quot;Minimum velocity is {min_vel}. Model may be input incorrectly&quot;)</span>
<span class="sd">        if max_vel &gt; 15000:</span>
<span class="sd">            Warning(f&quot;Maximum velocity is {max_vel}. Model may be input incorrectly&quot;)</span>

<span class="sd">        # If no velocity scaling is required.</span>
<span class="sd">        if type(vel_map) == type(None):</span>
<span class="sd">            vel_map = np.ones(veln.shape)</span>
<span class="sd">        # If no stifness tensors and density are being used.</span>
<span class="sd">        if type(stif_den) == type(None):</span>
<span class="sd">            stif_den = np.zeros((veln.shape[0], veln.shape[1], 5), dtype=np.int64)</span>
<span class="sd">        # Set up arrays for storing ray paths in the class.</span>
<span class="sd">        n_trans = len(self.isx)</span>
<span class="sd">        if save_rays:</span>
<span class="sd">            self.ray_paths_x = np.zeros((n_trans, n_trans, 5 * (veln.shape[0] + veln.shape[1])))</span>
<span class="sd">            self.ray_paths_y = np.copy(self.ray_paths_x)</span>
<span class="sd">            self.ray_len = np.zeros((n_trans, n_trans), dtype=int)</span>

<span class="sd">        if type(trans_pairs) == type(None):</span>
<span class="sd">            # If the ray paths that are required are not included then all combinations of transducers are used (each pair only uses one ray path i.e. transducer in each pair is either source or reciever.</span>
<span class="sd">            trans_pairs = np.zeros((n_trans, n_trans))</span>
<span class="sd">            for i in range(n_trans):</span>
<span class="sd">                for j in range(n_trans):</span>
<span class="sd">                    if i &lt; j:</span>
<span class="sd">                        trans_pairs[i, j] = 1</span>

<span class="sd">        # Determine which travel time fields needs calculating</span>
<span class="sd">        rec_trans = np.zeros(n_trans)</span>
<span class="sd">        for j in range(n_trans):</span>
<span class="sd">            if sum(trans_pairs[:, j]) &gt; 0:</span>
<span class="sd">                rec_trans[j] = 1</span>
<span class="sd">        #print(trans_pairs)</span>
<span class="sd">        #print(f&quot;total: {np.sum(trans_pairs)}&quot;)</span>
<span class="sd">        #print(rec_trans)</span>

<span class="sd">        # Calculate required travel time fields</span>
<span class="sd">        if n_threads_TTF == 1:</span>
<span class="sd">            TTFs = self.update(veln, velpn, vel_map, stif_den, subgrid_size, rec_trans)</span>
<span class="sd">        else:</span>
<span class="sd">            if low_mem == True:</span>
<span class="sd">                self.update_parallel(veln, velpn, vel_map, stif_den, subgrid_size, rec_trans, n_threads=n_threads_TTF, low_mem=True)</span>
<span class="sd">                TTFs = None</span>
<span class="sd">            else:</span>
<span class="sd">                TTFs = self.update_parallel(veln, velpn, vel_map, stif_den, subgrid_size, rec_trans, n_threads=n_threads_TTF, low_mem=False)</span>
<span class="sd">        #for i in range(n_trans):</span>
<span class="sd">        #    plt.contourf(TTFs[i, :, :], 20)</span>
<span class="sd">        #    plt.show()</span>

<span class="sd">        # Find transducer positions on finer grid.</span>
<span class="sd">        new_trans_x = subgrid_size * self.isx</span>
<span class="sd">        new_trans_y = subgrid_size * self.isz</span>
<span class="sd">        #print(self.isx, self.isz)</span>
<span class="sd">        #print(new_trans_x, new_trans_y)</span>
<span class="sd">        if type(trans_pairs) == type(None):</span>
<span class="sd">            trans_pairs = np.ones((n_trans, n_trans))</span>
<span class="sd">        # Array for storing ray times</span>
<span class="sd">        times = np.zeros((n_trans, n_trans))</span>


<span class="sd">        if n_threads_rays == 1:</span>
<span class="sd">            for i in range(n_trans):</span>
<span class="sd">                for j in range(n_trans): #for j in range(i + 1, len(self.isx)):</span>
<span class="sd">                    if i != j:</span>
<span class="sd">                        if trans_pairs[i, j] == 1:</span>
<span class="sd">                            # If ray path is required.</span>
<span class="sd">                            source = np.array([new_trans_x[i], new_trans_y[i]])</span>
<span class="sd">                            receiver = np.array([new_trans_x[j], new_trans_y[j]])</span>
<span class="sd">                            ray_x, ray_y, times[i, j] = find_ray(self.dnx, self.velocity_dat, source, receiver, TTFs[j, :, :], veln, velpn, vel_map, stif_den, subgrid_size)</span>

<span class="sd">                            # Move ray paths from finer grid back to original grid.</span>
<span class="sd">                            ray_x = ray_x / subgrid_size</span>
<span class="sd">                            ray_y = ray_y / subgrid_size</span>

<span class="sd">                            # Store ray path into class to be retrieved using class function ray_path</span>
<span class="sd">                            if save_rays:</span>
<span class="sd">                                ray_len = len(ray_x)</span>
<span class="sd">                                self.ray_paths_x[i, j, 0:ray_len] = ray_x</span>
<span class="sd">                                self.ray_paths_y[i, j, 0:ray_len] = ray_y</span>
<span class="sd">                                self.ray_len[i, j] = ray_len</span>
<span class="sd">        else:</span>
<span class="sd">            # Queue for sending data between processes.</span>
<span class="sd">            queue1 = multiprocessing.Queue()</span>
<span class="sd">            queue2 = multiprocessing.Queue()</span>
<span class="sd">            queue3 = multiprocessing.Queue()</span>
<span class="sd">            for i in range(n_trans):</span>
<span class="sd">                for j in range(n_trans):</span>
<span class="sd">                    if i != j:</span>
<span class="sd">                        if trans_pairs[i, j] == 1:</span>
<span class="sd">                            # add all required jobs into queue to be retrieved by other processes</span>
<span class="sd">                            source = np.array([new_trans_x[i], new_trans_y[i]])</span>
<span class="sd">                            receiver = np.array([new_trans_x[j], new_trans_y[j]])</span>
<span class="sd">                            queue1.put([i, j, source, receiver])</span>
<span class="sd">            # Set up worker processes</span>
<span class="sd">            processes = []</span>
<span class="sd">            for i in range(n_threads_rays):</span>
<span class="sd">                process = multiprocessing.Process(target=parallel_rays, args=(i, queue1, queue2, queue3, self.dnx, self.velocity_dat, TTFs, veln, velpn, vel_map, stif_den, subgrid_size))</span>
<span class="sd">                processes.append(process)</span>
<span class="sd">            # Start processes running</span>
<span class="sd">            for process in processes:</span>
<span class="sd">                process.start()</span>
<span class="sd">            # run until the correct number of ray paths has been retrieved.</span>
<span class="sd">            worker_jobs = np.zeros((n_threads_rays, 2), dtype=int)</span>
<span class="sd">            for ray_num in tqdm(range(int(np.sum(trans_pairs))), disable=tqdm_disable, ncols=100, desc=&quot;Finished ray paths&quot;, colour=&quot;green&quot;, bar_format=&quot;{l_bar} {bar} | {n_fmt}/{total_fmt} [{elapsed}]&quot;):</span>
<span class="sd">                #print(f&quot;rays completed {ray_num}/{int(np.sum(trans_pairs))}&quot;)</span>
<span class="sd">                #print(f&quot;{int(np.sum(trans_pairs))} , {ray_num}, {n_threads_rays}, {(int(np.sum(trans_pairs)) - ray_num) &gt; n_threads_rays}&quot;)</span>
<span class="sd">                while queue3.empty() == False:</span>
<span class="sd">                    [thread_num, ind_1, ind_2] = queue3.get()</span>
<span class="sd">                    worker_jobs[thread_num, :] = [ind_1, ind_2]</span>
<span class="sd">                if (int(np.sum(trans_pairs)) - ray_num) &gt; n_threads_rays:  # If almost finished main process checks for crashes periodically else checks when data is received</span>
<span class="sd">                    # Retrieve ray path and time from worker processes.</span>
<span class="sd">                    [i, j, ray_x, ray_y, time] = queue2.get()</span>
<span class="sd">                    # Store ray path into class to be retrieved using class function ray_path.</span>
<span class="sd">                    if save_rays:</span>
<span class="sd">                        ray_len = len(ray_x)</span>
<span class="sd">                        self.ray_paths_x[i, j, 0:ray_len] = ray_x</span>
<span class="sd">                        self.ray_paths_y[i, j, 0:ray_len] = ray_y</span>
<span class="sd">                        self.ray_len[i, j] = ray_len</span>
<span class="sd">                    times[i, j] = time</span>

<span class="sd">                    #activ_proc = np.zeros(n_threads_rays, dtype=bool)</span>
<span class="sd">                    for proc_num in range(n_threads_rays):</span>
<span class="sd">                        #activ_proc[proc_num] = processes[proc_num].is_alive()</span>
<span class="sd">                        if processes[proc_num].is_alive() == False:</span>
<span class="sd">                            print(f&quot;Process {proc_num} failed on ray [i,j] = {worker_jobs[proc_num, :]} with exit code {processes[proc_num].exitcode}\nRestarting Process\n&quot;, end=&quot;&quot;)</span>
<span class="sd">                            ind_1, ind_2 = worker_jobs[proc_num, :]</span>
<span class="sd">                            source = np.array([new_trans_x[ind_1], new_trans_y[ind_1]])</span>
<span class="sd">                            receiver = np.array([new_trans_x[ind_2], new_trans_y[ind_2]])</span>
<span class="sd">                            [ind_1, ind_2] = worker_jobs[proc_num, :]</span>
<span class="sd">                            queue1.put([int(ind_1), int(ind_2), source, receiver])</span>
<span class="sd">                            processes[proc_num] = multiprocessing.Process(target=parallel_rays, args=(proc_num, queue1, queue2, queue3, self.dnx, self.velocity_dat, TTFs, veln, velpn, vel_map, stif_den, subgrid_size))</span>
<span class="sd">                            processes[proc_num].start()</span>
<span class="sd">                    #print(f&quot;{np.sum(activ_proc)}/{n_threads_rays} Alive Processes :{activ_proc}&quot;)</span>
<span class="sd">                else:</span>
<span class="sd">                    while queue2.empty() == True:</span>
<span class="sd">                        for proc_num in range(n_threads_rays):</span>
<span class="sd">                            if processes[proc_num].is_alive() == False:</span>
<span class="sd">                                print(f&quot;Process {proc_num} failed on ray [i,j] = {worker_jobs[proc_num, :]} with exit code {processes[proc_num].exitcode}\nRestarting Process\n&quot;, end=&quot;&quot;)</span>
<span class="sd">                                ind_1, ind_2 = worker_jobs[proc_num, :]</span>
<span class="sd">                                source = np.array([new_trans_x[ind_1], new_trans_y[ind_1]])</span>
<span class="sd">                                receiver = np.array([new_trans_x[ind_2], new_trans_y[ind_2]])</span>
<span class="sd">                                [ind_1, ind_2] = worker_jobs[proc_num, :]</span>
<span class="sd">                                queue1.put([int(ind_1), int(ind_2), source, receiver])</span>
<span class="sd">                                processes[proc_num] = multiprocessing.Process(target=parallel_rays, args=(proc_num, queue1, queue2, queue3, self.dnx, self.velocity_dat, TTFs, veln, velpn, vel_map, stif_den, subgrid_size))</span>
<span class="sd">                                processes[proc_num].start()</span>
<span class="sd">                        sleep(0.5)</span>
<span class="sd">                    [i, j, ray_x, ray_y, time] = queue2.get()</span>
<span class="sd">                    # Store ray path into class to be retrieved using class function ray_path.</span>
<span class="sd">                    if save_rays:</span>
<span class="sd">                        ray_len = len(ray_x)</span>
<span class="sd">                        self.ray_paths_x[i, j, 0:ray_len] = ray_x</span>
<span class="sd">                        self.ray_paths_y[i, j, 0:ray_len] = ray_y</span>
<span class="sd">                        self.ray_len[i, j] = ray_len</span>
<span class="sd">                    times[i, j] = time</span>

<span class="sd">            # Terminate worker processes.</span>
<span class="sd">            for process in processes:</span>
<span class="sd">                process.terminate()</span>
<span class="sd">            # Wait for worker processes have finished terminating.</span>
<span class="sd">            for process in processes:</span>
<span class="sd">                process.join()</span>
<span class="sd">            # Close worker processes and return memory back to the os.</span>
<span class="sd">            for process in processes:</span>
<span class="sd">                process.close()</span>
<span class="sd">        return times</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="ALI_FMM.find_all_TTF_rays_parallel"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.find_all_TTF_rays_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">find_all_TTF_rays_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">trans_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stif_den</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">save_rays</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes travel time fields for required receivers and performs ray tracing between source and receiver pairs using parallelisation. Returns travel times, however ray paths can be obtained using the function ray_path. Each ray path is calculated in the same process as the receiver travel time field.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           Use __name__ == &quot;__main__&quot; in order to run in parallel.</span>

<span class="sd">        :param veln: Anisotropic material orientations at grid points. Set as an array of zeros if using isotropic materials.</span>
<span class="sd">        :type veln: 2D numpy array</span>
<span class="sd">        :param velpn: Material index of each grid point (0 if using stiffness tensors and density, otherwise index for column in velocity table).</span>
<span class="sd">        :type velpn: 2D numpy array of type int</span>
<span class="sd">        :param vel_map: Velocity scaling parameters for each grid point. Use array of ones for anisotropic materials, or array of velocities for isotropic materials. If unused then a array of ones is used.</span>
<span class="sd">        :type vel_map: 2D numpy array</span>
<span class="sd">        :param subgrid_size: Parameter for computing travel time field on finer grid (must be a odd number), multiply indices by subgrid_size to move between indices on original grid. Default value is set to 1 i.e same as original grid.</span>
<span class="sd">        :type subgrid_size: int</span>
<span class="sd">        :param trans_pairs: Transducer pairs where ray tracing is being performed (0 - No ray, 1 - compute ray). If parameter not used then all rays calculated(only one ray calculated per transducer pair i.e transducer is either source or receiver). Leading diagonal must have zeros.</span>
<span class="sd">        :type trans_pairs: 2D numpy array</span>
<span class="sd">        :param stif_den: Stiffness tensors at each grid point. First two indices are the position of the grid point and 3rd index is for the materials parameters, 0 - c_22, 1 - c_23, 2 - c_33, 3 - c_44, 4 - density. Array must use 64 bit integers with stiffness tensors in MPa and density in Kg/m^3. To use these values the material index of grid points should be 0. If a point is not using stiffness tensors and density the values are not used. If parameter not used, velocity curves will be used instead (don&#39;t set material index to 0).</span>
<span class="sd">        :type stif_den: 3D numpy array of type np.int64</span>
<span class="sd">        :param n_threads: Number of threads to be used.</span>
<span class="sd">        :type n_threads: int</span>
<span class="sd">        :param save_rays: Boolean value for if rays should be saved into class (rays can be obtained using ray_path function).</span>
<span class="sd">        :type save_rays: bool</span>
<span class="sd">        :return: Travel times along the ray paths. When the path is not calculated the value is 0.</span>
<span class="sd">        :rtype: 2D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_threads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_threads should not equal one. Use find_all_TTF_rays for single process.&quot;</span><span class="p">)</span>

        <span class="c1"># If no velocity scaling is required.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vel_map</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">vel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># If no stifness tensors and density are being used.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stif_den</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">stif_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="n">min_vel</span><span class="p">,</span> <span class="n">max_vel</span> <span class="o">=</span> <span class="n">min_max_vel</span><span class="p">(</span><span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_vel</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="ne">Warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum velocity is </span><span class="si">{</span><span class="n">min_vel</span><span class="si">}</span><span class="s2">. Model may be input incorrectly&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_vel</span> <span class="o">&gt;</span> <span class="mi">15000</span><span class="p">:</span>
            <span class="ne">Warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum velocity is </span><span class="si">{</span><span class="n">max_vel</span><span class="si">}</span><span class="s2">. Model may be input incorrectly&quot;</span><span class="p">)</span>

        <span class="c1"># Set up arrays for storing ray paths in the class.</span>
        <span class="n">n_trans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_rays</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">veln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># If the ray paths that are required are not included then all combinations of transducers are used (each pair only uses one ray path i.e. transducer in each pair is either source or reciever.</span>
            <span class="n">trans_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">trans_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Determine which travel time fields needs calculating</span>
        <span class="n">rec_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_trans</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rec_trans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1">#print(trans_pairs)</span>
        <span class="c1">#print(f&quot;total: {np.sum(trans_pairs)}&quot;)</span>
        <span class="c1">#print(rec_trans)</span>

        <span class="c1"># Calculate required travel time fields</span>

        <span class="c1">#for i in range(n_trans):</span>
        <span class="c1">#    plt.contourf(TTFs[i, :, :], 20)</span>
        <span class="c1">#    plt.show()</span>

        <span class="c1"># Find transducer positions on finer grid.</span>
        <span class="n">new_trans_x</span> <span class="o">=</span> <span class="n">subgrid_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">isx</span>
        <span class="n">new_trans_y</span> <span class="o">=</span> <span class="n">subgrid_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">isz</span>
        <span class="c1">#print(self.isx, self.isz)</span>
        <span class="c1">#print(new_trans_x, new_trans_y)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">trans_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">trans_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_rays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_pairs</span><span class="p">)</span>
        <span class="c1"># Array for storing ray times</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">))</span>

        <span class="n">rays_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trans</span><span class="p">,</span> <span class="n">n_trans</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>


        <span class="c1"># Queue for sending data between processes.</span>
        <span class="n">queue1</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="n">queue2</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="n">queue3</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trans</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rec_trans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">queue1</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">pbar_TTF</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rec_trans</span><span class="p">)),</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished TTF&#39;s    &quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">pbar_rays</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">n_rays</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">tqdm_disable</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Finished ray paths&quot;</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">bar_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{l_bar}</span><span class="s2"> </span><span class="si">{bar}</span><span class="s2"> | </span><span class="si">{n_fmt}</span><span class="s2">/</span><span class="si">{total_fmt}</span><span class="s2"> [</span><span class="si">{elapsed}</span><span class="s2">]&quot;</span><span class="p">)</span>


        <span class="c1"># Set up worker processes</span>
        <span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_threads</span><span class="p">):</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">parallel_TTF_rays</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">queue1</span><span class="p">,</span> <span class="n">queue2</span><span class="p">,</span> <span class="n">trans_pairs</span><span class="p">,</span> <span class="n">veln</span><span class="p">,</span> <span class="n">velpn</span><span class="p">,</span> <span class="n">vel_map</span><span class="p">,</span> <span class="n">stif_den</span><span class="p">,</span> <span class="n">subgrid_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_dat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">goz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dnx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scz</span><span class="p">,</span> <span class="n">new_trans_x</span><span class="p">,</span> <span class="n">new_trans_y</span><span class="p">))</span>
            <span class="c1"># Start processes running</span>
            <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">processes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="c1"># run until the correct number of ray paths has been retrieved.</span>
        <span class="n">n_rays_comp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">n_rays_comp</span> <span class="o">&lt;</span> <span class="n">n_rays</span><span class="p">:</span>
            <span class="p">[</span><span class="n">return_code</span><span class="p">,</span> <span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue2</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">return_code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pbar_TTF</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ray_x</span><span class="p">,</span> <span class="n">ray_y</span><span class="p">,</span> <span class="n">time</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="c1">#np.save(f&quot;ray_x_{i}_{j}.npy&quot;, ray_x)</span>
                <span class="c1">#np.save(f&quot;ray_y_{i}_{j}.npy&quot;, ray_y)</span>
                <span class="k">if</span> <span class="n">save_rays</span><span class="p">:</span>
                    <span class="n">ray_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ray_x</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ray_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_y</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_len</span>
                <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
                <span class="n">pbar_rays</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">n_rays_comp</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Terminate worker processes.</span>
        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="c1"># Wait for worker processes have finished terminating.</span>
        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="c1"># Close worker processes and return memory back to the os.</span>
        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">times</span></div>

<div class="viewcode-block" id="ALI_FMM.ray_path"><a class="viewcode-back" href="../Anis_TTF_class.html#Anis_TTF_rays.ALI_FMM.ray_path">[docs]</a>    <span class="k">def</span> <span class="nf">ray_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for returning the ray path for a given source and receiver which was calculated in the function find_all_TTF_rays. Will return None values if the path hasn&#39;t been calculated.</span>

<span class="sd">        :param i: Source index for the required ray path.</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :param j: Reciever index for the required ray path.</span>
<span class="sd">        :type j: int</span>
<span class="sd">        :return: ray_x, ray_y - Arrays for the x and y positions of points in the ray path. If there is no path then None values are returned.</span>
<span class="sd">        :rtype: 1D numpy array, 1D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if ray path exists.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ray path has not been calculated&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return ray path</span>
            <span class="n">ray_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_len</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ray_len</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_paths_y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ray_len</span><span class="p">]</span></div></div>









</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, James Ludlam.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>